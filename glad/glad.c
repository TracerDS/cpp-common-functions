/*

    OpenGL loader generated by glad 0.1.36 on Tue Feb 18 09:51:04 2025.

    Language/Generator: C/C++
    Specification: gl
    APIs: gl=3.3
    Profile: core
    Extensions:
        
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --profile="core" --api="gl=3.3" --generator="c" --spec="gl" --extensions=""
    Online:
        https://glad.dav1d.de/#profile=core&language=c&specification=gl&loader=on&api=gl%3D3.3
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include <glad/glad.h>

static void* get_proc(const char *namez);

#if defined(_WIN32) || defined(__CYGWIN__)
#ifndef _WINDOWS_
#undef APIENTRY
#endif
#include <windows.h>
static HMODULE libGL;

typedef void* (APIENTRYP PFNWGLGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNWGLGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;

#ifdef _MSC_VER
#ifdef __has_include
  #if __has_include(<winapifamily.h>)
    #define HAVE_WINAPIFAMILY 1
  #endif
#elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
  #define HAVE_WINAPIFAMILY 1
#endif
#endif

#ifdef HAVE_WINAPIFAMILY
  #include <winapifamily.h>
  #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
    #define IS_UWP 1
  #endif
#endif

static
int open_gl(void) {
#ifndef IS_UWP
    libGL = LoadLibraryW(L"opengl32.dll");
    if(libGL != NULL) {
        void (* tmp)(void);
        tmp = (void(*)(void)) GetProcAddress(libGL, "wglGetProcAddress");
        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE) tmp;
        return gladGetProcAddressPtr != NULL;
    }
#endif

    return 0;
}

static
void close_gl(void) {
    if(libGL != NULL) {
        FreeLibrary((HMODULE) libGL);
        libGL = NULL;
    }
}
#else
#include <dlfcn.h>
static void* libGL;

#if !defined(__APPLE__) && !defined(__HAIKU__)
typedef void* (APIENTRYP PFNGLXGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNGLXGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;
#endif

static
int open_gl(void) {
#ifdef __APPLE__
    static const char *NAMES[] = {
        "../Frameworks/OpenGL.framework/OpenGL",
        "/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
    };
#else
    static const char *NAMES[] = {"libGL.so.1", "libGL.so"};
#endif

    unsigned int index = 0;
    for(index = 0; index < (sizeof(NAMES) / sizeof(NAMES[0])); index++) {
        libGL = dlopen(NAMES[index], RTLD_NOW | RTLD_GLOBAL);

        if(libGL != NULL) {
#if defined(__APPLE__) || defined(__HAIKU__)
            return 1;
#else
            gladGetProcAddressPtr = (PFNGLXGETPROCADDRESSPROC_PRIVATE)dlsym(libGL,
                "glXGetProcAddressARB");
            return gladGetProcAddressPtr != NULL;
#endif
        }
    }

    return 0;
}

static
void close_gl(void) {
    if(libGL != NULL) {
        dlclose(libGL);
        libGL = NULL;
    }
}
#endif

static
void* get_proc(const char *namez) {
    void* result = NULL;
    if(libGL == NULL) return NULL;

#if !defined(__APPLE__) && !defined(__HAIKU__)
    if(gladGetProcAddressPtr != NULL) {
        result = gladGetProcAddressPtr(namez);
    }
#endif
    if(result == NULL) {
#if defined(_WIN32) || defined(__CYGWIN__)
        result = (void*)GetProcAddress((HMODULE) libGL, namez);
#else
        result = dlsym(libGL, namez);
#endif
    }

    return result;
}

int gladLoadGL(void) {
    int status = 0;

    if(open_gl()) {
        status = gladLoadGLLoader(&get_proc);
        close_gl();
    }

    return status;
}

struct gladGLversionStruct GLVersion = { 0, 0 };

#if defined(GL_ES_VERSION_3_0) || defined(GL_VERSION_3_0)
#define _GLAD_IS_SOME_NEW_VERSION 1
#endif

static int max_loaded_major;
static int max_loaded_minor;

static const char *exts = NULL;
static int num_exts_i = 0;
static char **exts_i = NULL;

static int get_exts(void) {
#ifdef _GLAD_IS_SOME_NEW_VERSION
    if(max_loaded_major < 3) {
#endif
        exts = (const char *)glGetString(GL_EXTENSIONS);
#ifdef _GLAD_IS_SOME_NEW_VERSION
    } else {
        int index;

        num_exts_i = 0;
        glGetIntegerv(GL_NUM_EXTENSIONS, &num_exts_i);
        if (num_exts_i > 0) {
            exts_i = (char **)malloc((size_t)num_exts_i * (sizeof *exts_i));
        }

        if (exts_i == NULL) {
            return 0;
        }

        for(index = 0; index < num_exts_i; index++) {
            const char *gl_str_tmp = (const char*)glGetStringi(GL_EXTENSIONS, index);
            size_t len = strlen(gl_str_tmp);

            char *local_str = (char*)malloc((len+1) * sizeof(char));
            if(local_str != NULL) {
                memcpy(local_str, gl_str_tmp, (len+1) * sizeof(char));
            }
            exts_i[index] = local_str;
        }
    }
#endif
    return 1;
}

static void free_exts(void) {
    if (exts_i != NULL) {
        int index;
        for(index = 0; index < num_exts_i; index++) {
            free((char *)exts_i[index]);
        }
        free((void *)exts_i);
        exts_i = NULL;
    }
}

static int has_ext(const char *ext) {
#ifdef _GLAD_IS_SOME_NEW_VERSION
    if(max_loaded_major < 3) {
#endif
        const char *extensions;
        const char *loc;
        const char *terminator;
        extensions = exts;
        if(extensions == NULL || ext == NULL) {
            return 0;
        }

        while(1) {
            loc = strstr(extensions, ext);
            if(loc == NULL) {
                return 0;
            }

            terminator = loc + strlen(ext);
            if((loc == extensions || *(loc - 1) == ' ') &&
                (*terminator == ' ' || *terminator == '\0')) {
                return 1;
            }
            extensions = terminator;
        }
#ifdef _GLAD_IS_SOME_NEW_VERSION
    } else {
        int index;
        if(exts_i == NULL) return 0;
        for(index = 0; index < num_exts_i; index++) {
            const char *e = exts_i[index];

            if(exts_i[index] != NULL && strcmp(e, ext) == 0) {
                return 1;
            }
        }
    }
#endif

    return 0;
}

int GLAD_GL_VERSION_1_0 = 0;
int GLAD_GL_VERSION_1_1 = 0;
int GLAD_GL_VERSION_1_2 = 0;
int GLAD_GL_VERSION_1_3 = 0;
int GLAD_GL_VERSION_1_4 = 0;
int GLAD_GL_VERSION_1_5 = 0;
int GLAD_GL_VERSION_2_0 = 0;
int GLAD_GL_VERSION_2_1 = 0;
int GLAD_GL_VERSION_3_0 = 0;
int GLAD_GL_VERSION_3_1 = 0;
int GLAD_GL_VERSION_3_2 = 0;
int GLAD_GL_VERSION_3_3 = 0;
int GLAD_GL_VERSION_4_0 = 0;
int GLAD_GL_VERSION_4_1 = 0;
int GLAD_GL_VERSION_4_2 = 0;
int GLAD_GL_VERSION_4_3 = 0;
int GLAD_GL_VERSION_4_4 = 0;
int GLAD_GL_VERSION_4_5 = 0;
int GLAD_GL_VERSION_4_6 = 0;
PFNGLACTIVESHADERPROGRAMPROC glad_glActiveShaderProgram = NULL;
PFNGLACTIVETEXTUREPROC glad_glActiveTexture = NULL;
PFNGLATTACHSHADERPROC glad_glAttachShader = NULL;
PFNGLBEGINCONDITIONALRENDERPROC glad_glBeginConditionalRender = NULL;
PFNGLBEGINQUERYPROC glad_glBeginQuery = NULL;
PFNGLBEGINQUERYINDEXEDPROC glad_glBeginQueryIndexed = NULL;
PFNGLBEGINTRANSFORMFEEDBACKPROC glad_glBeginTransformFeedback = NULL;
PFNGLBINDATTRIBLOCATIONPROC glad_glBindAttribLocation = NULL;
PFNGLBINDBUFFERPROC glad_glBindBuffer = NULL;
PFNGLBINDBUFFERBASEPROC glad_glBindBufferBase = NULL;
PFNGLBINDBUFFERRANGEPROC glad_glBindBufferRange = NULL;
PFNGLBINDBUFFERSBASEPROC glad_glBindBuffersBase = NULL;
PFNGLBINDBUFFERSRANGEPROC glad_glBindBuffersRange = NULL;
PFNGLBINDFRAGDATALOCATIONPROC glad_glBindFragDataLocation = NULL;
PFNGLBINDFRAGDATALOCATIONINDEXEDPROC glad_glBindFragDataLocationIndexed = NULL;
PFNGLBINDFRAMEBUFFERPROC glad_glBindFramebuffer = NULL;
PFNGLBINDIMAGETEXTUREPROC glad_glBindImageTexture = NULL;
PFNGLBINDIMAGETEXTURESPROC glad_glBindImageTextures = NULL;
PFNGLBINDPROGRAMPIPELINEPROC glad_glBindProgramPipeline = NULL;
PFNGLBINDRENDERBUFFERPROC glad_glBindRenderbuffer = NULL;
PFNGLBINDSAMPLERPROC glad_glBindSampler = NULL;
PFNGLBINDSAMPLERSPROC glad_glBindSamplers = NULL;
PFNGLBINDTEXTUREPROC glad_glBindTexture = NULL;
PFNGLBINDTEXTUREUNITPROC glad_glBindTextureUnit = NULL;
PFNGLBINDTEXTURESPROC glad_glBindTextures = NULL;
PFNGLBINDTRANSFORMFEEDBACKPROC glad_glBindTransformFeedback = NULL;
PFNGLBINDVERTEXARRAYPROC glad_glBindVertexArray = NULL;
PFNGLBINDVERTEXBUFFERPROC glad_glBindVertexBuffer = NULL;
PFNGLBINDVERTEXBUFFERSPROC glad_glBindVertexBuffers = NULL;
PFNGLBLENDCOLORPROC glad_glBlendColor = NULL;
PFNGLBLENDEQUATIONPROC glad_glBlendEquation = NULL;
PFNGLBLENDEQUATIONSEPARATEPROC glad_glBlendEquationSeparate = NULL;
PFNGLBLENDEQUATIONSEPARATEIPROC glad_glBlendEquationSeparatei = NULL;
PFNGLBLENDEQUATIONIPROC glad_glBlendEquationi = NULL;
PFNGLBLENDFUNCPROC glad_glBlendFunc = NULL;
PFNGLBLENDFUNCSEPARATEPROC glad_glBlendFuncSeparate = NULL;
PFNGLBLENDFUNCSEPARATEIPROC glad_glBlendFuncSeparatei = NULL;
PFNGLBLENDFUNCIPROC glad_glBlendFunci = NULL;
PFNGLBLITFRAMEBUFFERPROC glad_glBlitFramebuffer = NULL;
PFNGLBLITNAMEDFRAMEBUFFERPROC glad_glBlitNamedFramebuffer = NULL;
PFNGLBUFFERDATAPROC glad_glBufferData = NULL;
PFNGLBUFFERSTORAGEPROC glad_glBufferStorage = NULL;
PFNGLBUFFERSUBDATAPROC glad_glBufferSubData = NULL;
PFNGLCHECKFRAMEBUFFERSTATUSPROC glad_glCheckFramebufferStatus = NULL;
PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC glad_glCheckNamedFramebufferStatus = NULL;
PFNGLCLAMPCOLORPROC glad_glClampColor = NULL;
PFNGLCLEARPROC glad_glClear = NULL;
PFNGLCLEARBUFFERDATAPROC glad_glClearBufferData = NULL;
PFNGLCLEARBUFFERSUBDATAPROC glad_glClearBufferSubData = NULL;
PFNGLCLEARBUFFERFIPROC glad_glClearBufferfi = NULL;
PFNGLCLEARBUFFERFVPROC glad_glClearBufferfv = NULL;
PFNGLCLEARBUFFERIVPROC glad_glClearBufferiv = NULL;
PFNGLCLEARBUFFERUIVPROC glad_glClearBufferuiv = NULL;
PFNGLCLEARCOLORPROC glad_glClearColor = NULL;
PFNGLCLEARDEPTHPROC glad_glClearDepth = NULL;
PFNGLCLEARDEPTHFPROC glad_glClearDepthf = NULL;
PFNGLCLEARNAMEDBUFFERDATAPROC glad_glClearNamedBufferData = NULL;
PFNGLCLEARNAMEDBUFFERSUBDATAPROC glad_glClearNamedBufferSubData = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFIPROC glad_glClearNamedFramebufferfi = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERFVPROC glad_glClearNamedFramebufferfv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERIVPROC glad_glClearNamedFramebufferiv = NULL;
PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC glad_glClearNamedFramebufferuiv = NULL;
PFNGLCLEARSTENCILPROC glad_glClearStencil = NULL;
PFNGLCLEARTEXIMAGEPROC glad_glClearTexImage = NULL;
PFNGLCLEARTEXSUBIMAGEPROC glad_glClearTexSubImage = NULL;
PFNGLCLIENTWAITSYNCPROC glad_glClientWaitSync = NULL;
PFNGLCLIPCONTROLPROC glad_glClipControl = NULL;
PFNGLCOLORMASKPROC glad_glColorMask = NULL;
PFNGLCOLORMASKIPROC glad_glColorMaski = NULL;
PFNGLCOLORP3UIPROC glad_glColorP3ui = NULL;
PFNGLCOLORP3UIVPROC glad_glColorP3uiv = NULL;
PFNGLCOLORP4UIPROC glad_glColorP4ui = NULL;
PFNGLCOLORP4UIVPROC glad_glColorP4uiv = NULL;
PFNGLCOMPILESHADERPROC glad_glCompileShader = NULL;
PFNGLCOMPRESSEDTEXIMAGE1DPROC glad_glCompressedTexImage1D = NULL;
PFNGLCOMPRESSEDTEXIMAGE2DPROC glad_glCompressedTexImage2D = NULL;
PFNGLCOMPRESSEDTEXIMAGE3DPROC glad_glCompressedTexImage3D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC glad_glCompressedTexSubImage1D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC glad_glCompressedTexSubImage2D = NULL;
PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC glad_glCompressedTexSubImage3D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC glad_glCompressedTextureSubImage1D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC glad_glCompressedTextureSubImage2D = NULL;
PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC glad_glCompressedTextureSubImage3D = NULL;
PFNGLCOPYBUFFERSUBDATAPROC glad_glCopyBufferSubData = NULL;
PFNGLCOPYIMAGESUBDATAPROC glad_glCopyImageSubData = NULL;
PFNGLCOPYNAMEDBUFFERSUBDATAPROC glad_glCopyNamedBufferSubData = NULL;
PFNGLCOPYTEXIMAGE1DPROC glad_glCopyTexImage1D = NULL;
PFNGLCOPYTEXIMAGE2DPROC glad_glCopyTexImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE1DPROC glad_glCopyTexSubImage1D = NULL;
PFNGLCOPYTEXSUBIMAGE2DPROC glad_glCopyTexSubImage2D = NULL;
PFNGLCOPYTEXSUBIMAGE3DPROC glad_glCopyTexSubImage3D = NULL;
PFNGLCOPYTEXTURESUBIMAGE1DPROC glad_glCopyTextureSubImage1D = NULL;
PFNGLCOPYTEXTURESUBIMAGE2DPROC glad_glCopyTextureSubImage2D = NULL;
PFNGLCOPYTEXTURESUBIMAGE3DPROC glad_glCopyTextureSubImage3D = NULL;
PFNGLCREATEBUFFERSPROC glad_glCreateBuffers = NULL;
PFNGLCREATEFRAMEBUFFERSPROC glad_glCreateFramebuffers = NULL;
PFNGLCREATEPROGRAMPROC glad_glCreateProgram = NULL;
PFNGLCREATEPROGRAMPIPELINESPROC glad_glCreateProgramPipelines = NULL;
PFNGLCREATEQUERIESPROC glad_glCreateQueries = NULL;
PFNGLCREATERENDERBUFFERSPROC glad_glCreateRenderbuffers = NULL;
PFNGLCREATESAMPLERSPROC glad_glCreateSamplers = NULL;
PFNGLCREATESHADERPROC glad_glCreateShader = NULL;
PFNGLCREATESHADERPROGRAMVPROC glad_glCreateShaderProgramv = NULL;
PFNGLCREATETEXTURESPROC glad_glCreateTextures = NULL;
PFNGLCREATETRANSFORMFEEDBACKSPROC glad_glCreateTransformFeedbacks = NULL;
PFNGLCREATEVERTEXARRAYSPROC glad_glCreateVertexArrays = NULL;
PFNGLCULLFACEPROC glad_glCullFace = NULL;
PFNGLDEBUGMESSAGECALLBACKPROC glad_glDebugMessageCallback = NULL;
PFNGLDEBUGMESSAGECONTROLPROC glad_glDebugMessageControl = NULL;
PFNGLDEBUGMESSAGEINSERTPROC glad_glDebugMessageInsert = NULL;
PFNGLDELETEBUFFERSPROC glad_glDeleteBuffers = NULL;
PFNGLDELETEFRAMEBUFFERSPROC glad_glDeleteFramebuffers = NULL;
PFNGLDELETEPROGRAMPROC glad_glDeleteProgram = NULL;
PFNGLDELETEPROGRAMPIPELINESPROC glad_glDeleteProgramPipelines = NULL;
PFNGLDELETEQUERIESPROC glad_glDeleteQueries = NULL;
PFNGLDELETERENDERBUFFERSPROC glad_glDeleteRenderbuffers = NULL;
PFNGLDELETESAMPLERSPROC glad_glDeleteSamplers = NULL;
PFNGLDELETESHADERPROC glad_glDeleteShader = NULL;
PFNGLDELETESYNCPROC glad_glDeleteSync = NULL;
PFNGLDELETETEXTURESPROC glad_glDeleteTextures = NULL;
PFNGLDELETETRANSFORMFEEDBACKSPROC glad_glDeleteTransformFeedbacks = NULL;
PFNGLDELETEVERTEXARRAYSPROC glad_glDeleteVertexArrays = NULL;
PFNGLDEPTHFUNCPROC glad_glDepthFunc = NULL;
PFNGLDEPTHMASKPROC glad_glDepthMask = NULL;
PFNGLDEPTHRANGEPROC glad_glDepthRange = NULL;
PFNGLDEPTHRANGEARRAYVPROC glad_glDepthRangeArrayv = NULL;
PFNGLDEPTHRANGEINDEXEDPROC glad_glDepthRangeIndexed = NULL;
PFNGLDEPTHRANGEFPROC glad_glDepthRangef = NULL;
PFNGLDETACHSHADERPROC glad_glDetachShader = NULL;
PFNGLDISABLEPROC glad_glDisable = NULL;
PFNGLDISABLEVERTEXARRAYATTRIBPROC glad_glDisableVertexArrayAttrib = NULL;
PFNGLDISABLEVERTEXATTRIBARRAYPROC glad_glDisableVertexAttribArray = NULL;
PFNGLDISABLEIPROC glad_glDisablei = NULL;
PFNGLDISPATCHCOMPUTEPROC glad_glDispatchCompute = NULL;
PFNGLDISPATCHCOMPUTEINDIRECTPROC glad_glDispatchComputeIndirect = NULL;
PFNGLDRAWARRAYSPROC glad_glDrawArrays = NULL;
PFNGLDRAWARRAYSINDIRECTPROC glad_glDrawArraysIndirect = NULL;
PFNGLDRAWARRAYSINSTANCEDPROC glad_glDrawArraysInstanced = NULL;
PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC glad_glDrawArraysInstancedBaseInstance = NULL;
PFNGLDRAWBUFFERPROC glad_glDrawBuffer = NULL;
PFNGLDRAWBUFFERSPROC glad_glDrawBuffers = NULL;
PFNGLDRAWELEMENTSPROC glad_glDrawElements = NULL;
PFNGLDRAWELEMENTSBASEVERTEXPROC glad_glDrawElementsBaseVertex = NULL;
PFNGLDRAWELEMENTSINDIRECTPROC glad_glDrawElementsIndirect = NULL;
PFNGLDRAWELEMENTSINSTANCEDPROC glad_glDrawElementsInstanced = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC glad_glDrawElementsInstancedBaseInstance = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC glad_glDrawElementsInstancedBaseVertex = NULL;
PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC glad_glDrawElementsInstancedBaseVertexBaseInstance = NULL;
PFNGLDRAWRANGEELEMENTSPROC glad_glDrawRangeElements = NULL;
PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC glad_glDrawRangeElementsBaseVertex = NULL;
PFNGLDRAWTRANSFORMFEEDBACKPROC glad_glDrawTransformFeedback = NULL;
PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC glad_glDrawTransformFeedbackInstanced = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC glad_glDrawTransformFeedbackStream = NULL;
PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC glad_glDrawTransformFeedbackStreamInstanced = NULL;
PFNGLENABLEPROC glad_glEnable = NULL;
PFNGLENABLEVERTEXARRAYATTRIBPROC glad_glEnableVertexArrayAttrib = NULL;
PFNGLENABLEVERTEXATTRIBARRAYPROC glad_glEnableVertexAttribArray = NULL;
PFNGLENABLEIPROC glad_glEnablei = NULL;
PFNGLENDCONDITIONALRENDERPROC glad_glEndConditionalRender = NULL;
PFNGLENDQUERYPROC glad_glEndQuery = NULL;
PFNGLENDQUERYINDEXEDPROC glad_glEndQueryIndexed = NULL;
PFNGLENDTRANSFORMFEEDBACKPROC glad_glEndTransformFeedback = NULL;
PFNGLFENCESYNCPROC glad_glFenceSync = NULL;
PFNGLFINISHPROC glad_glFinish = NULL;
PFNGLFLUSHPROC glad_glFlush = NULL;
PFNGLFLUSHMAPPEDBUFFERRANGEPROC glad_glFlushMappedBufferRange = NULL;
PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC glad_glFlushMappedNamedBufferRange = NULL;
PFNGLFRAMEBUFFERPARAMETERIPROC glad_glFramebufferParameteri = NULL;
PFNGLFRAMEBUFFERRENDERBUFFERPROC glad_glFramebufferRenderbuffer = NULL;
PFNGLFRAMEBUFFERTEXTUREPROC glad_glFramebufferTexture = NULL;
PFNGLFRAMEBUFFERTEXTURE1DPROC glad_glFramebufferTexture1D = NULL;
PFNGLFRAMEBUFFERTEXTURE2DPROC glad_glFramebufferTexture2D = NULL;
PFNGLFRAMEBUFFERTEXTURE3DPROC glad_glFramebufferTexture3D = NULL;
PFNGLFRAMEBUFFERTEXTURELAYERPROC glad_glFramebufferTextureLayer = NULL;
PFNGLFRONTFACEPROC glad_glFrontFace = NULL;
PFNGLGENBUFFERSPROC glad_glGenBuffers = NULL;
PFNGLGENFRAMEBUFFERSPROC glad_glGenFramebuffers = NULL;
PFNGLGENPROGRAMPIPELINESPROC glad_glGenProgramPipelines = NULL;
PFNGLGENQUERIESPROC glad_glGenQueries = NULL;
PFNGLGENRENDERBUFFERSPROC glad_glGenRenderbuffers = NULL;
PFNGLGENSAMPLERSPROC glad_glGenSamplers = NULL;
PFNGLGENTEXTURESPROC glad_glGenTextures = NULL;
PFNGLGENTRANSFORMFEEDBACKSPROC glad_glGenTransformFeedbacks = NULL;
PFNGLGENVERTEXARRAYSPROC glad_glGenVertexArrays = NULL;
PFNGLGENERATEMIPMAPPROC glad_glGenerateMipmap = NULL;
PFNGLGENERATETEXTUREMIPMAPPROC glad_glGenerateTextureMipmap = NULL;
PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC glad_glGetActiveAtomicCounterBufferiv = NULL;
PFNGLGETACTIVEATTRIBPROC glad_glGetActiveAttrib = NULL;
PFNGLGETACTIVESUBROUTINENAMEPROC glad_glGetActiveSubroutineName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC glad_glGetActiveSubroutineUniformName = NULL;
PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC glad_glGetActiveSubroutineUniformiv = NULL;
PFNGLGETACTIVEUNIFORMPROC glad_glGetActiveUniform = NULL;
PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC glad_glGetActiveUniformBlockName = NULL;
PFNGLGETACTIVEUNIFORMBLOCKIVPROC glad_glGetActiveUniformBlockiv = NULL;
PFNGLGETACTIVEUNIFORMNAMEPROC glad_glGetActiveUniformName = NULL;
PFNGLGETACTIVEUNIFORMSIVPROC glad_glGetActiveUniformsiv = NULL;
PFNGLGETATTACHEDSHADERSPROC glad_glGetAttachedShaders = NULL;
PFNGLGETATTRIBLOCATIONPROC glad_glGetAttribLocation = NULL;
PFNGLGETBOOLEANI_VPROC glad_glGetBooleani_v = NULL;
PFNGLGETBOOLEANVPROC glad_glGetBooleanv = NULL;
PFNGLGETBUFFERPARAMETERI64VPROC glad_glGetBufferParameteri64v = NULL;
PFNGLGETBUFFERPARAMETERIVPROC glad_glGetBufferParameteriv = NULL;
PFNGLGETBUFFERPOINTERVPROC glad_glGetBufferPointerv = NULL;
PFNGLGETBUFFERSUBDATAPROC glad_glGetBufferSubData = NULL;
PFNGLGETCOMPRESSEDTEXIMAGEPROC glad_glGetCompressedTexImage = NULL;
PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC glad_glGetCompressedTextureImage = NULL;
PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC glad_glGetCompressedTextureSubImage = NULL;
PFNGLGETDEBUGMESSAGELOGPROC glad_glGetDebugMessageLog = NULL;
PFNGLGETDOUBLEI_VPROC glad_glGetDoublei_v = NULL;
PFNGLGETDOUBLEVPROC glad_glGetDoublev = NULL;
PFNGLGETERRORPROC glad_glGetError = NULL;
PFNGLGETFLOATI_VPROC glad_glGetFloati_v = NULL;
PFNGLGETFLOATVPROC glad_glGetFloatv = NULL;
PFNGLGETFRAGDATAINDEXPROC glad_glGetFragDataIndex = NULL;
PFNGLGETFRAGDATALOCATIONPROC glad_glGetFragDataLocation = NULL;
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetFramebufferAttachmentParameteriv = NULL;
PFNGLGETFRAMEBUFFERPARAMETERIVPROC glad_glGetFramebufferParameteriv = NULL;
PFNGLGETGRAPHICSRESETSTATUSPROC glad_glGetGraphicsResetStatus = NULL;
PFNGLGETINTEGER64I_VPROC glad_glGetInteger64i_v = NULL;
PFNGLGETINTEGER64VPROC glad_glGetInteger64v = NULL;
PFNGLGETINTEGERI_VPROC glad_glGetIntegeri_v = NULL;
PFNGLGETINTEGERVPROC glad_glGetIntegerv = NULL;
PFNGLGETINTERNALFORMATI64VPROC glad_glGetInternalformati64v = NULL;
PFNGLGETINTERNALFORMATIVPROC glad_glGetInternalformativ = NULL;
PFNGLGETMULTISAMPLEFVPROC glad_glGetMultisamplefv = NULL;
PFNGLGETNAMEDBUFFERPARAMETERI64VPROC glad_glGetNamedBufferParameteri64v = NULL;
PFNGLGETNAMEDBUFFERPARAMETERIVPROC glad_glGetNamedBufferParameteriv = NULL;
PFNGLGETNAMEDBUFFERPOINTERVPROC glad_glGetNamedBufferPointerv = NULL;
PFNGLGETNAMEDBUFFERSUBDATAPROC glad_glGetNamedBufferSubData = NULL;
PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC glad_glGetNamedFramebufferAttachmentParameteriv = NULL;
PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC glad_glGetNamedFramebufferParameteriv = NULL;
PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC glad_glGetNamedRenderbufferParameteriv = NULL;
PFNGLGETOBJECTLABELPROC glad_glGetObjectLabel = NULL;
PFNGLGETOBJECTPTRLABELPROC glad_glGetObjectPtrLabel = NULL;
PFNGLGETPOINTERVPROC glad_glGetPointerv = NULL;
PFNGLGETPROGRAMBINARYPROC glad_glGetProgramBinary = NULL;
PFNGLGETPROGRAMINFOLOGPROC glad_glGetProgramInfoLog = NULL;
PFNGLGETPROGRAMINTERFACEIVPROC glad_glGetProgramInterfaceiv = NULL;
PFNGLGETPROGRAMPIPELINEINFOLOGPROC glad_glGetProgramPipelineInfoLog = NULL;
PFNGLGETPROGRAMPIPELINEIVPROC glad_glGetProgramPipelineiv = NULL;
PFNGLGETPROGRAMRESOURCEINDEXPROC glad_glGetProgramResourceIndex = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONPROC glad_glGetProgramResourceLocation = NULL;
PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC glad_glGetProgramResourceLocationIndex = NULL;
PFNGLGETPROGRAMRESOURCENAMEPROC glad_glGetProgramResourceName = NULL;
PFNGLGETPROGRAMRESOURCEIVPROC glad_glGetProgramResourceiv = NULL;
PFNGLGETPROGRAMSTAGEIVPROC glad_glGetProgramStageiv = NULL;
PFNGLGETPROGRAMIVPROC glad_glGetProgramiv = NULL;
PFNGLGETQUERYBUFFEROBJECTI64VPROC glad_glGetQueryBufferObjecti64v = NULL;
PFNGLGETQUERYBUFFEROBJECTIVPROC glad_glGetQueryBufferObjectiv = NULL;
PFNGLGETQUERYBUFFEROBJECTUI64VPROC glad_glGetQueryBufferObjectui64v = NULL;
PFNGLGETQUERYBUFFEROBJECTUIVPROC glad_glGetQueryBufferObjectuiv = NULL;
PFNGLGETQUERYINDEXEDIVPROC glad_glGetQueryIndexediv = NULL;
PFNGLGETQUERYOBJECTI64VPROC glad_glGetQueryObjecti64v = NULL;
PFNGLGETQUERYOBJECTIVPROC glad_glGetQueryObjectiv = NULL;
PFNGLGETQUERYOBJECTUI64VPROC glad_glGetQueryObjectui64v = NULL;
PFNGLGETQUERYOBJECTUIVPROC glad_glGetQueryObjectuiv = NULL;
PFNGLGETQUERYIVPROC glad_glGetQueryiv = NULL;
PFNGLGETRENDERBUFFERPARAMETERIVPROC glad_glGetRenderbufferParameteriv = NULL;
PFNGLGETSAMPLERPARAMETERIIVPROC glad_glGetSamplerParameterIiv = NULL;
PFNGLGETSAMPLERPARAMETERIUIVPROC glad_glGetSamplerParameterIuiv = NULL;
PFNGLGETSAMPLERPARAMETERFVPROC glad_glGetSamplerParameterfv = NULL;
PFNGLGETSAMPLERPARAMETERIVPROC glad_glGetSamplerParameteriv = NULL;
PFNGLGETSHADERINFOLOGPROC glad_glGetShaderInfoLog = NULL;
PFNGLGETSHADERPRECISIONFORMATPROC glad_glGetShaderPrecisionFormat = NULL;
PFNGLGETSHADERSOURCEPROC glad_glGetShaderSource = NULL;
PFNGLGETSHADERIVPROC glad_glGetShaderiv = NULL;
PFNGLGETSTRINGPROC glad_glGetString = NULL;
PFNGLGETSTRINGIPROC glad_glGetStringi = NULL;
PFNGLGETSUBROUTINEINDEXPROC glad_glGetSubroutineIndex = NULL;
PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC glad_glGetSubroutineUniformLocation = NULL;
PFNGLGETSYNCIVPROC glad_glGetSynciv = NULL;
PFNGLGETTEXIMAGEPROC glad_glGetTexImage = NULL;
PFNGLGETTEXLEVELPARAMETERFVPROC glad_glGetTexLevelParameterfv = NULL;
PFNGLGETTEXLEVELPARAMETERIVPROC glad_glGetTexLevelParameteriv = NULL;
PFNGLGETTEXPARAMETERIIVPROC glad_glGetTexParameterIiv = NULL;
PFNGLGETTEXPARAMETERIUIVPROC glad_glGetTexParameterIuiv = NULL;
PFNGLGETTEXPARAMETERFVPROC glad_glGetTexParameterfv = NULL;
PFNGLGETTEXPARAMETERIVPROC glad_glGetTexParameteriv = NULL;
PFNGLGETTEXTUREIMAGEPROC glad_glGetTextureImage = NULL;
PFNGLGETTEXTURELEVELPARAMETERFVPROC glad_glGetTextureLevelParameterfv = NULL;
PFNGLGETTEXTURELEVELPARAMETERIVPROC glad_glGetTextureLevelParameteriv = NULL;
PFNGLGETTEXTUREPARAMETERIIVPROC glad_glGetTextureParameterIiv = NULL;
PFNGLGETTEXTUREPARAMETERIUIVPROC glad_glGetTextureParameterIuiv = NULL;
PFNGLGETTEXTUREPARAMETERFVPROC glad_glGetTextureParameterfv = NULL;
PFNGLGETTEXTUREPARAMETERIVPROC glad_glGetTextureParameteriv = NULL;
PFNGLGETTEXTURESUBIMAGEPROC glad_glGetTextureSubImage = NULL;
PFNGLGETTRANSFORMFEEDBACKVARYINGPROC glad_glGetTransformFeedbackVarying = NULL;
PFNGLGETTRANSFORMFEEDBACKI64_VPROC glad_glGetTransformFeedbacki64_v = NULL;
PFNGLGETTRANSFORMFEEDBACKI_VPROC glad_glGetTransformFeedbacki_v = NULL;
PFNGLGETTRANSFORMFEEDBACKIVPROC glad_glGetTransformFeedbackiv = NULL;
PFNGLGETUNIFORMBLOCKINDEXPROC glad_glGetUniformBlockIndex = NULL;
PFNGLGETUNIFORMINDICESPROC glad_glGetUniformIndices = NULL;
PFNGLGETUNIFORMLOCATIONPROC glad_glGetUniformLocation = NULL;
PFNGLGETUNIFORMSUBROUTINEUIVPROC glad_glGetUniformSubroutineuiv = NULL;
PFNGLGETUNIFORMDVPROC glad_glGetUniformdv = NULL;
PFNGLGETUNIFORMFVPROC glad_glGetUniformfv = NULL;
PFNGLGETUNIFORMIVPROC glad_glGetUniformiv = NULL;
PFNGLGETUNIFORMUIVPROC glad_glGetUniformuiv = NULL;
PFNGLGETVERTEXARRAYINDEXED64IVPROC glad_glGetVertexArrayIndexed64iv = NULL;
PFNGLGETVERTEXARRAYINDEXEDIVPROC glad_glGetVertexArrayIndexediv = NULL;
PFNGLGETVERTEXARRAYIVPROC glad_glGetVertexArrayiv = NULL;
PFNGLGETVERTEXATTRIBIIVPROC glad_glGetVertexAttribIiv = NULL;
PFNGLGETVERTEXATTRIBIUIVPROC glad_glGetVertexAttribIuiv = NULL;
PFNGLGETVERTEXATTRIBLDVPROC glad_glGetVertexAttribLdv = NULL;
PFNGLGETVERTEXATTRIBPOINTERVPROC glad_glGetVertexAttribPointerv = NULL;
PFNGLGETVERTEXATTRIBDVPROC glad_glGetVertexAttribdv = NULL;
PFNGLGETVERTEXATTRIBFVPROC glad_glGetVertexAttribfv = NULL;
PFNGLGETVERTEXATTRIBIVPROC glad_glGetVertexAttribiv = NULL;
PFNGLGETNCOLORTABLEPROC glad_glGetnColorTable = NULL;
PFNGLGETNCOMPRESSEDTEXIMAGEPROC glad_glGetnCompressedTexImage = NULL;
PFNGLGETNCONVOLUTIONFILTERPROC glad_glGetnConvolutionFilter = NULL;
PFNGLGETNHISTOGRAMPROC glad_glGetnHistogram = NULL;
PFNGLGETNMAPDVPROC glad_glGetnMapdv = NULL;
PFNGLGETNMAPFVPROC glad_glGetnMapfv = NULL;
PFNGLGETNMAPIVPROC glad_glGetnMapiv = NULL;
PFNGLGETNMINMAXPROC glad_glGetnMinmax = NULL;
PFNGLGETNPIXELMAPFVPROC glad_glGetnPixelMapfv = NULL;
PFNGLGETNPIXELMAPUIVPROC glad_glGetnPixelMapuiv = NULL;
PFNGLGETNPIXELMAPUSVPROC glad_glGetnPixelMapusv = NULL;
PFNGLGETNPOLYGONSTIPPLEPROC glad_glGetnPolygonStipple = NULL;
PFNGLGETNSEPARABLEFILTERPROC glad_glGetnSeparableFilter = NULL;
PFNGLGETNTEXIMAGEPROC glad_glGetnTexImage = NULL;
PFNGLGETNUNIFORMDVPROC glad_glGetnUniformdv = NULL;
PFNGLGETNUNIFORMFVPROC glad_glGetnUniformfv = NULL;
PFNGLGETNUNIFORMIVPROC glad_glGetnUniformiv = NULL;
PFNGLGETNUNIFORMUIVPROC glad_glGetnUniformuiv = NULL;
PFNGLHINTPROC glad_glHint = NULL;
PFNGLINVALIDATEBUFFERDATAPROC glad_glInvalidateBufferData = NULL;
PFNGLINVALIDATEBUFFERSUBDATAPROC glad_glInvalidateBufferSubData = NULL;
PFNGLINVALIDATEFRAMEBUFFERPROC glad_glInvalidateFramebuffer = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC glad_glInvalidateNamedFramebufferData = NULL;
PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC glad_glInvalidateNamedFramebufferSubData = NULL;
PFNGLINVALIDATESUBFRAMEBUFFERPROC glad_glInvalidateSubFramebuffer = NULL;
PFNGLINVALIDATETEXIMAGEPROC glad_glInvalidateTexImage = NULL;
PFNGLINVALIDATETEXSUBIMAGEPROC glad_glInvalidateTexSubImage = NULL;
PFNGLISBUFFERPROC glad_glIsBuffer = NULL;
PFNGLISENABLEDPROC glad_glIsEnabled = NULL;
PFNGLISENABLEDIPROC glad_glIsEnabledi = NULL;
PFNGLISFRAMEBUFFERPROC glad_glIsFramebuffer = NULL;
PFNGLISPROGRAMPROC glad_glIsProgram = NULL;
PFNGLISPROGRAMPIPELINEPROC glad_glIsProgramPipeline = NULL;
PFNGLISQUERYPROC glad_glIsQuery = NULL;
PFNGLISRENDERBUFFERPROC glad_glIsRenderbuffer = NULL;
PFNGLISSAMPLERPROC glad_glIsSampler = NULL;
PFNGLISSHADERPROC glad_glIsShader = NULL;
PFNGLISSYNCPROC glad_glIsSync = NULL;
PFNGLISTEXTUREPROC glad_glIsTexture = NULL;
PFNGLISTRANSFORMFEEDBACKPROC glad_glIsTransformFeedback = NULL;
PFNGLISVERTEXARRAYPROC glad_glIsVertexArray = NULL;
PFNGLLINEWIDTHPROC glad_glLineWidth = NULL;
PFNGLLINKPROGRAMPROC glad_glLinkProgram = NULL;
PFNGLLOGICOPPROC glad_glLogicOp = NULL;
PFNGLMAPBUFFERPROC glad_glMapBuffer = NULL;
PFNGLMAPBUFFERRANGEPROC glad_glMapBufferRange = NULL;
PFNGLMAPNAMEDBUFFERPROC glad_glMapNamedBuffer = NULL;
PFNGLMAPNAMEDBUFFERRANGEPROC glad_glMapNamedBufferRange = NULL;
PFNGLMEMORYBARRIERPROC glad_glMemoryBarrier = NULL;
PFNGLMEMORYBARRIERBYREGIONPROC glad_glMemoryBarrierByRegion = NULL;
PFNGLMINSAMPLESHADINGPROC glad_glMinSampleShading = NULL;
PFNGLMULTIDRAWARRAYSPROC glad_glMultiDrawArrays = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTPROC glad_glMultiDrawArraysIndirect = NULL;
PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC glad_glMultiDrawArraysIndirectCount = NULL;
PFNGLMULTIDRAWELEMENTSPROC glad_glMultiDrawElements = NULL;
PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC glad_glMultiDrawElementsBaseVertex = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTPROC glad_glMultiDrawElementsIndirect = NULL;
PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC glad_glMultiDrawElementsIndirectCount = NULL;
PFNGLMULTITEXCOORDP1UIPROC glad_glMultiTexCoordP1ui = NULL;
PFNGLMULTITEXCOORDP1UIVPROC glad_glMultiTexCoordP1uiv = NULL;
PFNGLMULTITEXCOORDP2UIPROC glad_glMultiTexCoordP2ui = NULL;
PFNGLMULTITEXCOORDP2UIVPROC glad_glMultiTexCoordP2uiv = NULL;
PFNGLMULTITEXCOORDP3UIPROC glad_glMultiTexCoordP3ui = NULL;
PFNGLMULTITEXCOORDP3UIVPROC glad_glMultiTexCoordP3uiv = NULL;
PFNGLMULTITEXCOORDP4UIPROC glad_glMultiTexCoordP4ui = NULL;
PFNGLMULTITEXCOORDP4UIVPROC glad_glMultiTexCoordP4uiv = NULL;
PFNGLNAMEDBUFFERDATAPROC glad_glNamedBufferData = NULL;
PFNGLNAMEDBUFFERSTORAGEPROC glad_glNamedBufferStorage = NULL;
PFNGLNAMEDBUFFERSUBDATAPROC glad_glNamedBufferSubData = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC glad_glNamedFramebufferDrawBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC glad_glNamedFramebufferDrawBuffers = NULL;
PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC glad_glNamedFramebufferParameteri = NULL;
PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC glad_glNamedFramebufferReadBuffer = NULL;
PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC glad_glNamedFramebufferRenderbuffer = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTUREPROC glad_glNamedFramebufferTexture = NULL;
PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC glad_glNamedFramebufferTextureLayer = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEPROC glad_glNamedRenderbufferStorage = NULL;
PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glNamedRenderbufferStorageMultisample = NULL;
PFNGLNORMALP3UIPROC glad_glNormalP3ui = NULL;
PFNGLNORMALP3UIVPROC glad_glNormalP3uiv = NULL;
PFNGLOBJECTLABELPROC glad_glObjectLabel = NULL;
PFNGLOBJECTPTRLABELPROC glad_glObjectPtrLabel = NULL;
PFNGLPATCHPARAMETERFVPROC glad_glPatchParameterfv = NULL;
PFNGLPATCHPARAMETERIPROC glad_glPatchParameteri = NULL;
PFNGLPAUSETRANSFORMFEEDBACKPROC glad_glPauseTransformFeedback = NULL;
PFNGLPIXELSTOREFPROC glad_glPixelStoref = NULL;
PFNGLPIXELSTOREIPROC glad_glPixelStorei = NULL;
PFNGLPOINTPARAMETERFPROC glad_glPointParameterf = NULL;
PFNGLPOINTPARAMETERFVPROC glad_glPointParameterfv = NULL;
PFNGLPOINTPARAMETERIPROC glad_glPointParameteri = NULL;
PFNGLPOINTPARAMETERIVPROC glad_glPointParameteriv = NULL;
PFNGLPOINTSIZEPROC glad_glPointSize = NULL;
PFNGLPOLYGONMODEPROC glad_glPolygonMode = NULL;
PFNGLPOLYGONOFFSETPROC glad_glPolygonOffset = NULL;
PFNGLPOLYGONOFFSETCLAMPPROC glad_glPolygonOffsetClamp = NULL;
PFNGLPOPDEBUGGROUPPROC glad_glPopDebugGroup = NULL;
PFNGLPRIMITIVERESTARTINDEXPROC glad_glPrimitiveRestartIndex = NULL;
PFNGLPROGRAMBINARYPROC glad_glProgramBinary = NULL;
PFNGLPROGRAMPARAMETERIPROC glad_glProgramParameteri = NULL;
PFNGLPROGRAMUNIFORM1DPROC glad_glProgramUniform1d = NULL;
PFNGLPROGRAMUNIFORM1DVPROC glad_glProgramUniform1dv = NULL;
PFNGLPROGRAMUNIFORM1FPROC glad_glProgramUniform1f = NULL;
PFNGLPROGRAMUNIFORM1FVPROC glad_glProgramUniform1fv = NULL;
PFNGLPROGRAMUNIFORM1IPROC glad_glProgramUniform1i = NULL;
PFNGLPROGRAMUNIFORM1IVPROC glad_glProgramUniform1iv = NULL;
PFNGLPROGRAMUNIFORM1UIPROC glad_glProgramUniform1ui = NULL;
PFNGLPROGRAMUNIFORM1UIVPROC glad_glProgramUniform1uiv = NULL;
PFNGLPROGRAMUNIFORM2DPROC glad_glProgramUniform2d = NULL;
PFNGLPROGRAMUNIFORM2DVPROC glad_glProgramUniform2dv = NULL;
PFNGLPROGRAMUNIFORM2FPROC glad_glProgramUniform2f = NULL;
PFNGLPROGRAMUNIFORM2FVPROC glad_glProgramUniform2fv = NULL;
PFNGLPROGRAMUNIFORM2IPROC glad_glProgramUniform2i = NULL;
PFNGLPROGRAMUNIFORM2IVPROC glad_glProgramUniform2iv = NULL;
PFNGLPROGRAMUNIFORM2UIPROC glad_glProgramUniform2ui = NULL;
PFNGLPROGRAMUNIFORM2UIVPROC glad_glProgramUniform2uiv = NULL;
PFNGLPROGRAMUNIFORM3DPROC glad_glProgramUniform3d = NULL;
PFNGLPROGRAMUNIFORM3DVPROC glad_glProgramUniform3dv = NULL;
PFNGLPROGRAMUNIFORM3FPROC glad_glProgramUniform3f = NULL;
PFNGLPROGRAMUNIFORM3FVPROC glad_glProgramUniform3fv = NULL;
PFNGLPROGRAMUNIFORM3IPROC glad_glProgramUniform3i = NULL;
PFNGLPROGRAMUNIFORM3IVPROC glad_glProgramUniform3iv = NULL;
PFNGLPROGRAMUNIFORM3UIPROC glad_glProgramUniform3ui = NULL;
PFNGLPROGRAMUNIFORM3UIVPROC glad_glProgramUniform3uiv = NULL;
PFNGLPROGRAMUNIFORM4DPROC glad_glProgramUniform4d = NULL;
PFNGLPROGRAMUNIFORM4DVPROC glad_glProgramUniform4dv = NULL;
PFNGLPROGRAMUNIFORM4FPROC glad_glProgramUniform4f = NULL;
PFNGLPROGRAMUNIFORM4FVPROC glad_glProgramUniform4fv = NULL;
PFNGLPROGRAMUNIFORM4IPROC glad_glProgramUniform4i = NULL;
PFNGLPROGRAMUNIFORM4IVPROC glad_glProgramUniform4iv = NULL;
PFNGLPROGRAMUNIFORM4UIPROC glad_glProgramUniform4ui = NULL;
PFNGLPROGRAMUNIFORM4UIVPROC glad_glProgramUniform4uiv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2DVPROC glad_glProgramUniformMatrix2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2FVPROC glad_glProgramUniformMatrix2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC glad_glProgramUniformMatrix2x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC glad_glProgramUniformMatrix2x3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC glad_glProgramUniformMatrix2x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC glad_glProgramUniformMatrix2x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3DVPROC glad_glProgramUniformMatrix3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3FVPROC glad_glProgramUniformMatrix3fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC glad_glProgramUniformMatrix3x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC glad_glProgramUniformMatrix3x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC glad_glProgramUniformMatrix3x4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC glad_glProgramUniformMatrix3x4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4DVPROC glad_glProgramUniformMatrix4dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4FVPROC glad_glProgramUniformMatrix4fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC glad_glProgramUniformMatrix4x2dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC glad_glProgramUniformMatrix4x2fv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC glad_glProgramUniformMatrix4x3dv = NULL;
PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC glad_glProgramUniformMatrix4x3fv = NULL;
PFNGLPROVOKINGVERTEXPROC glad_glProvokingVertex = NULL;
PFNGLPUSHDEBUGGROUPPROC glad_glPushDebugGroup = NULL;
PFNGLQUERYCOUNTERPROC glad_glQueryCounter = NULL;
PFNGLREADBUFFERPROC glad_glReadBuffer = NULL;
PFNGLREADPIXELSPROC glad_glReadPixels = NULL;
PFNGLREADNPIXELSPROC glad_glReadnPixels = NULL;
PFNGLRELEASESHADERCOMPILERPROC glad_glReleaseShaderCompiler = NULL;
PFNGLRENDERBUFFERSTORAGEPROC glad_glRenderbufferStorage = NULL;
PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC glad_glRenderbufferStorageMultisample = NULL;
PFNGLRESUMETRANSFORMFEEDBACKPROC glad_glResumeTransformFeedback = NULL;
PFNGLSAMPLECOVERAGEPROC glad_glSampleCoverage = NULL;
PFNGLSAMPLEMASKIPROC glad_glSampleMaski = NULL;
PFNGLSAMPLERPARAMETERIIVPROC glad_glSamplerParameterIiv = NULL;
PFNGLSAMPLERPARAMETERIUIVPROC glad_glSamplerParameterIuiv = NULL;
PFNGLSAMPLERPARAMETERFPROC glad_glSamplerParameterf = NULL;
PFNGLSAMPLERPARAMETERFVPROC glad_glSamplerParameterfv = NULL;
PFNGLSAMPLERPARAMETERIPROC glad_glSamplerParameteri = NULL;
PFNGLSAMPLERPARAMETERIVPROC glad_glSamplerParameteriv = NULL;
PFNGLSCISSORPROC glad_glScissor = NULL;
PFNGLSCISSORARRAYVPROC glad_glScissorArrayv = NULL;
PFNGLSCISSORINDEXEDPROC glad_glScissorIndexed = NULL;
PFNGLSCISSORINDEXEDVPROC glad_glScissorIndexedv = NULL;
PFNGLSECONDARYCOLORP3UIPROC glad_glSecondaryColorP3ui = NULL;
PFNGLSECONDARYCOLORP3UIVPROC glad_glSecondaryColorP3uiv = NULL;
PFNGLSHADERBINARYPROC glad_glShaderBinary = NULL;
PFNGLSHADERSOURCEPROC glad_glShaderSource = NULL;
PFNGLSHADERSTORAGEBLOCKBINDINGPROC glad_glShaderStorageBlockBinding = NULL;
PFNGLSPECIALIZESHADERPROC glad_glSpecializeShader = NULL;
PFNGLSTENCILFUNCPROC glad_glStencilFunc = NULL;
PFNGLSTENCILFUNCSEPARATEPROC glad_glStencilFuncSeparate = NULL;
PFNGLSTENCILMASKPROC glad_glStencilMask = NULL;
PFNGLSTENCILMASKSEPARATEPROC glad_glStencilMaskSeparate = NULL;
PFNGLSTENCILOPPROC glad_glStencilOp = NULL;
PFNGLSTENCILOPSEPARATEPROC glad_glStencilOpSeparate = NULL;
PFNGLTEXBUFFERPROC glad_glTexBuffer = NULL;
PFNGLTEXBUFFERRANGEPROC glad_glTexBufferRange = NULL;
PFNGLTEXCOORDP1UIPROC glad_glTexCoordP1ui = NULL;
PFNGLTEXCOORDP1UIVPROC glad_glTexCoordP1uiv = NULL;
PFNGLTEXCOORDP2UIPROC glad_glTexCoordP2ui = NULL;
PFNGLTEXCOORDP2UIVPROC glad_glTexCoordP2uiv = NULL;
PFNGLTEXCOORDP3UIPROC glad_glTexCoordP3ui = NULL;
PFNGLTEXCOORDP3UIVPROC glad_glTexCoordP3uiv = NULL;
PFNGLTEXCOORDP4UIPROC glad_glTexCoordP4ui = NULL;
PFNGLTEXCOORDP4UIVPROC glad_glTexCoordP4uiv = NULL;
PFNGLTEXIMAGE1DPROC glad_glTexImage1D = NULL;
PFNGLTEXIMAGE2DPROC glad_glTexImage2D = NULL;
PFNGLTEXIMAGE2DMULTISAMPLEPROC glad_glTexImage2DMultisample = NULL;
PFNGLTEXIMAGE3DPROC glad_glTexImage3D = NULL;
PFNGLTEXIMAGE3DMULTISAMPLEPROC glad_glTexImage3DMultisample = NULL;
PFNGLTEXPARAMETERIIVPROC glad_glTexParameterIiv = NULL;
PFNGLTEXPARAMETERIUIVPROC glad_glTexParameterIuiv = NULL;
PFNGLTEXPARAMETERFPROC glad_glTexParameterf = NULL;
PFNGLTEXPARAMETERFVPROC glad_glTexParameterfv = NULL;
PFNGLTEXPARAMETERIPROC glad_glTexParameteri = NULL;
PFNGLTEXPARAMETERIVPROC glad_glTexParameteriv = NULL;
PFNGLTEXSTORAGE1DPROC glad_glTexStorage1D = NULL;
PFNGLTEXSTORAGE2DPROC glad_glTexStorage2D = NULL;
PFNGLTEXSTORAGE2DMULTISAMPLEPROC glad_glTexStorage2DMultisample = NULL;
PFNGLTEXSTORAGE3DPROC glad_glTexStorage3D = NULL;
PFNGLTEXSTORAGE3DMULTISAMPLEPROC glad_glTexStorage3DMultisample = NULL;
PFNGLTEXSUBIMAGE1DPROC glad_glTexSubImage1D = NULL;
PFNGLTEXSUBIMAGE2DPROC glad_glTexSubImage2D = NULL;
PFNGLTEXSUBIMAGE3DPROC glad_glTexSubImage3D = NULL;
PFNGLTEXTUREBARRIERPROC glad_glTextureBarrier = NULL;
PFNGLTEXTUREBUFFERPROC glad_glTextureBuffer = NULL;
PFNGLTEXTUREBUFFERRANGEPROC glad_glTextureBufferRange = NULL;
PFNGLTEXTUREPARAMETERIIVPROC glad_glTextureParameterIiv = NULL;
PFNGLTEXTUREPARAMETERIUIVPROC glad_glTextureParameterIuiv = NULL;
PFNGLTEXTUREPARAMETERFPROC glad_glTextureParameterf = NULL;
PFNGLTEXTUREPARAMETERFVPROC glad_glTextureParameterfv = NULL;
PFNGLTEXTUREPARAMETERIPROC glad_glTextureParameteri = NULL;
PFNGLTEXTUREPARAMETERIVPROC glad_glTextureParameteriv = NULL;
PFNGLTEXTURESTORAGE1DPROC glad_glTextureStorage1D = NULL;
PFNGLTEXTURESTORAGE2DPROC glad_glTextureStorage2D = NULL;
PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC glad_glTextureStorage2DMultisample = NULL;
PFNGLTEXTURESTORAGE3DPROC glad_glTextureStorage3D = NULL;
PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC glad_glTextureStorage3DMultisample = NULL;
PFNGLTEXTURESUBIMAGE1DPROC glad_glTextureSubImage1D = NULL;
PFNGLTEXTURESUBIMAGE2DPROC glad_glTextureSubImage2D = NULL;
PFNGLTEXTURESUBIMAGE3DPROC glad_glTextureSubImage3D = NULL;
PFNGLTEXTUREVIEWPROC glad_glTextureView = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC glad_glTransformFeedbackBufferBase = NULL;
PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC glad_glTransformFeedbackBufferRange = NULL;
PFNGLTRANSFORMFEEDBACKVARYINGSPROC glad_glTransformFeedbackVaryings = NULL;
PFNGLUNIFORM1DPROC glad_glUniform1d = NULL;
PFNGLUNIFORM1DVPROC glad_glUniform1dv = NULL;
PFNGLUNIFORM1FPROC glad_glUniform1f = NULL;
PFNGLUNIFORM1FVPROC glad_glUniform1fv = NULL;
PFNGLUNIFORM1IPROC glad_glUniform1i = NULL;
PFNGLUNIFORM1IVPROC glad_glUniform1iv = NULL;
PFNGLUNIFORM1UIPROC glad_glUniform1ui = NULL;
PFNGLUNIFORM1UIVPROC glad_glUniform1uiv = NULL;
PFNGLUNIFORM2DPROC glad_glUniform2d = NULL;
PFNGLUNIFORM2DVPROC glad_glUniform2dv = NULL;
PFNGLUNIFORM2FPROC glad_glUniform2f = NULL;
PFNGLUNIFORM2FVPROC glad_glUniform2fv = NULL;
PFNGLUNIFORM2IPROC glad_glUniform2i = NULL;
PFNGLUNIFORM2IVPROC glad_glUniform2iv = NULL;
PFNGLUNIFORM2UIPROC glad_glUniform2ui = NULL;
PFNGLUNIFORM2UIVPROC glad_glUniform2uiv = NULL;
PFNGLUNIFORM3DPROC glad_glUniform3d = NULL;
PFNGLUNIFORM3DVPROC glad_glUniform3dv = NULL;
PFNGLUNIFORM3FPROC glad_glUniform3f = NULL;
PFNGLUNIFORM3FVPROC glad_glUniform3fv = NULL;
PFNGLUNIFORM3IPROC glad_glUniform3i = NULL;
PFNGLUNIFORM3IVPROC glad_glUniform3iv = NULL;
PFNGLUNIFORM3UIPROC glad_glUniform3ui = NULL;
PFNGLUNIFORM3UIVPROC glad_glUniform3uiv = NULL;
PFNGLUNIFORM4DPROC glad_glUniform4d = NULL;
PFNGLUNIFORM4DVPROC glad_glUniform4dv = NULL;
PFNGLUNIFORM4FPROC glad_glUniform4f = NULL;
PFNGLUNIFORM4FVPROC glad_glUniform4fv = NULL;
PFNGLUNIFORM4IPROC glad_glUniform4i = NULL;
PFNGLUNIFORM4IVPROC glad_glUniform4iv = NULL;
PFNGLUNIFORM4UIPROC glad_glUniform4ui = NULL;
PFNGLUNIFORM4UIVPROC glad_glUniform4uiv = NULL;
PFNGLUNIFORMBLOCKBINDINGPROC glad_glUniformBlockBinding = NULL;
PFNGLUNIFORMMATRIX2DVPROC glad_glUniformMatrix2dv = NULL;
PFNGLUNIFORMMATRIX2FVPROC glad_glUniformMatrix2fv = NULL;
PFNGLUNIFORMMATRIX2X3DVPROC glad_glUniformMatrix2x3dv = NULL;
PFNGLUNIFORMMATRIX2X3FVPROC glad_glUniformMatrix2x3fv = NULL;
PFNGLUNIFORMMATRIX2X4DVPROC glad_glUniformMatrix2x4dv = NULL;
PFNGLUNIFORMMATRIX2X4FVPROC glad_glUniformMatrix2x4fv = NULL;
PFNGLUNIFORMMATRIX3DVPROC glad_glUniformMatrix3dv = NULL;
PFNGLUNIFORMMATRIX3FVPROC glad_glUniformMatrix3fv = NULL;
PFNGLUNIFORMMATRIX3X2DVPROC glad_glUniformMatrix3x2dv = NULL;
PFNGLUNIFORMMATRIX3X2FVPROC glad_glUniformMatrix3x2fv = NULL;
PFNGLUNIFORMMATRIX3X4DVPROC glad_glUniformMatrix3x4dv = NULL;
PFNGLUNIFORMMATRIX3X4FVPROC glad_glUniformMatrix3x4fv = NULL;
PFNGLUNIFORMMATRIX4DVPROC glad_glUniformMatrix4dv = NULL;
PFNGLUNIFORMMATRIX4FVPROC glad_glUniformMatrix4fv = NULL;
PFNGLUNIFORMMATRIX4X2DVPROC glad_glUniformMatrix4x2dv = NULL;
PFNGLUNIFORMMATRIX4X2FVPROC glad_glUniformMatrix4x2fv = NULL;
PFNGLUNIFORMMATRIX4X3DVPROC glad_glUniformMatrix4x3dv = NULL;
PFNGLUNIFORMMATRIX4X3FVPROC glad_glUniformMatrix4x3fv = NULL;
PFNGLUNIFORMSUBROUTINESUIVPROC glad_glUniformSubroutinesuiv = NULL;
PFNGLUNMAPBUFFERPROC glad_glUnmapBuffer = NULL;
PFNGLUNMAPNAMEDBUFFERPROC glad_glUnmapNamedBuffer = NULL;
PFNGLUSEPROGRAMPROC glad_glUseProgram = NULL;
PFNGLUSEPROGRAMSTAGESPROC glad_glUseProgramStages = NULL;
PFNGLVALIDATEPROGRAMPROC glad_glValidateProgram = NULL;
PFNGLVALIDATEPROGRAMPIPELINEPROC glad_glValidateProgramPipeline = NULL;
PFNGLVERTEXARRAYATTRIBBINDINGPROC glad_glVertexArrayAttribBinding = NULL;
PFNGLVERTEXARRAYATTRIBFORMATPROC glad_glVertexArrayAttribFormat = NULL;
PFNGLVERTEXARRAYATTRIBIFORMATPROC glad_glVertexArrayAttribIFormat = NULL;
PFNGLVERTEXARRAYATTRIBLFORMATPROC glad_glVertexArrayAttribLFormat = NULL;
PFNGLVERTEXARRAYBINDINGDIVISORPROC glad_glVertexArrayBindingDivisor = NULL;
PFNGLVERTEXARRAYELEMENTBUFFERPROC glad_glVertexArrayElementBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERPROC glad_glVertexArrayVertexBuffer = NULL;
PFNGLVERTEXARRAYVERTEXBUFFERSPROC glad_glVertexArrayVertexBuffers = NULL;
PFNGLVERTEXATTRIB1DPROC glad_glVertexAttrib1d = NULL;
PFNGLVERTEXATTRIB1DVPROC glad_glVertexAttrib1dv = NULL;
PFNGLVERTEXATTRIB1FPROC glad_glVertexAttrib1f = NULL;
PFNGLVERTEXATTRIB1FVPROC glad_glVertexAttrib1fv = NULL;
PFNGLVERTEXATTRIB1SPROC glad_glVertexAttrib1s = NULL;
PFNGLVERTEXATTRIB1SVPROC glad_glVertexAttrib1sv = NULL;
PFNGLVERTEXATTRIB2DPROC glad_glVertexAttrib2d = NULL;
PFNGLVERTEXATTRIB2DVPROC glad_glVertexAttrib2dv = NULL;
PFNGLVERTEXATTRIB2FPROC glad_glVertexAttrib2f = NULL;
PFNGLVERTEXATTRIB2FVPROC glad_glVertexAttrib2fv = NULL;
PFNGLVERTEXATTRIB2SPROC glad_glVertexAttrib2s = NULL;
PFNGLVERTEXATTRIB2SVPROC glad_glVertexAttrib2sv = NULL;
PFNGLVERTEXATTRIB3DPROC glad_glVertexAttrib3d = NULL;
PFNGLVERTEXATTRIB3DVPROC glad_glVertexAttrib3dv = NULL;
PFNGLVERTEXATTRIB3FPROC glad_glVertexAttrib3f = NULL;
PFNGLVERTEXATTRIB3FVPROC glad_glVertexAttrib3fv = NULL;
PFNGLVERTEXATTRIB3SPROC glad_glVertexAttrib3s = NULL;
PFNGLVERTEXATTRIB3SVPROC glad_glVertexAttrib3sv = NULL;
PFNGLVERTEXATTRIB4NBVPROC glad_glVertexAttrib4Nbv = NULL;
PFNGLVERTEXATTRIB4NIVPROC glad_glVertexAttrib4Niv = NULL;
PFNGLVERTEXATTRIB4NSVPROC glad_glVertexAttrib4Nsv = NULL;
PFNGLVERTEXATTRIB4NUBPROC glad_glVertexAttrib4Nub = NULL;
PFNGLVERTEXATTRIB4NUBVPROC glad_glVertexAttrib4Nubv = NULL;
PFNGLVERTEXATTRIB4NUIVPROC glad_glVertexAttrib4Nuiv = NULL;
PFNGLVERTEXATTRIB4NUSVPROC glad_glVertexAttrib4Nusv = NULL;
PFNGLVERTEXATTRIB4BVPROC glad_glVertexAttrib4bv = NULL;
PFNGLVERTEXATTRIB4DPROC glad_glVertexAttrib4d = NULL;
PFNGLVERTEXATTRIB4DVPROC glad_glVertexAttrib4dv = NULL;
PFNGLVERTEXATTRIB4FPROC glad_glVertexAttrib4f = NULL;
PFNGLVERTEXATTRIB4FVPROC glad_glVertexAttrib4fv = NULL;
PFNGLVERTEXATTRIB4IVPROC glad_glVertexAttrib4iv = NULL;
PFNGLVERTEXATTRIB4SPROC glad_glVertexAttrib4s = NULL;
PFNGLVERTEXATTRIB4SVPROC glad_glVertexAttrib4sv = NULL;
PFNGLVERTEXATTRIB4UBVPROC glad_glVertexAttrib4ubv = NULL;
PFNGLVERTEXATTRIB4UIVPROC glad_glVertexAttrib4uiv = NULL;
PFNGLVERTEXATTRIB4USVPROC glad_glVertexAttrib4usv = NULL;
PFNGLVERTEXATTRIBBINDINGPROC glad_glVertexAttribBinding = NULL;
PFNGLVERTEXATTRIBDIVISORPROC glad_glVertexAttribDivisor = NULL;
PFNGLVERTEXATTRIBFORMATPROC glad_glVertexAttribFormat = NULL;
PFNGLVERTEXATTRIBI1IPROC glad_glVertexAttribI1i = NULL;
PFNGLVERTEXATTRIBI1IVPROC glad_glVertexAttribI1iv = NULL;
PFNGLVERTEXATTRIBI1UIPROC glad_glVertexAttribI1ui = NULL;
PFNGLVERTEXATTRIBI1UIVPROC glad_glVertexAttribI1uiv = NULL;
PFNGLVERTEXATTRIBI2IPROC glad_glVertexAttribI2i = NULL;
PFNGLVERTEXATTRIBI2IVPROC glad_glVertexAttribI2iv = NULL;
PFNGLVERTEXATTRIBI2UIPROC glad_glVertexAttribI2ui = NULL;
PFNGLVERTEXATTRIBI2UIVPROC glad_glVertexAttribI2uiv = NULL;
PFNGLVERTEXATTRIBI3IPROC glad_glVertexAttribI3i = NULL;
PFNGLVERTEXATTRIBI3IVPROC glad_glVertexAttribI3iv = NULL;
PFNGLVERTEXATTRIBI3UIPROC glad_glVertexAttribI3ui = NULL;
PFNGLVERTEXATTRIBI3UIVPROC glad_glVertexAttribI3uiv = NULL;
PFNGLVERTEXATTRIBI4BVPROC glad_glVertexAttribI4bv = NULL;
PFNGLVERTEXATTRIBI4IPROC glad_glVertexAttribI4i = NULL;
PFNGLVERTEXATTRIBI4IVPROC glad_glVertexAttribI4iv = NULL;
PFNGLVERTEXATTRIBI4SVPROC glad_glVertexAttribI4sv = NULL;
PFNGLVERTEXATTRIBI4UBVPROC glad_glVertexAttribI4ubv = NULL;
PFNGLVERTEXATTRIBI4UIPROC glad_glVertexAttribI4ui = NULL;
PFNGLVERTEXATTRIBI4UIVPROC glad_glVertexAttribI4uiv = NULL;
PFNGLVERTEXATTRIBI4USVPROC glad_glVertexAttribI4usv = NULL;
PFNGLVERTEXATTRIBIFORMATPROC glad_glVertexAttribIFormat = NULL;
PFNGLVERTEXATTRIBIPOINTERPROC glad_glVertexAttribIPointer = NULL;
PFNGLVERTEXATTRIBL1DPROC glad_glVertexAttribL1d = NULL;
PFNGLVERTEXATTRIBL1DVPROC glad_glVertexAttribL1dv = NULL;
PFNGLVERTEXATTRIBL2DPROC glad_glVertexAttribL2d = NULL;
PFNGLVERTEXATTRIBL2DVPROC glad_glVertexAttribL2dv = NULL;
PFNGLVERTEXATTRIBL3DPROC glad_glVertexAttribL3d = NULL;
PFNGLVERTEXATTRIBL3DVPROC glad_glVertexAttribL3dv = NULL;
PFNGLVERTEXATTRIBL4DPROC glad_glVertexAttribL4d = NULL;
PFNGLVERTEXATTRIBL4DVPROC glad_glVertexAttribL4dv = NULL;
PFNGLVERTEXATTRIBLFORMATPROC glad_glVertexAttribLFormat = NULL;
PFNGLVERTEXATTRIBLPOINTERPROC glad_glVertexAttribLPointer = NULL;
PFNGLVERTEXATTRIBP1UIPROC glad_glVertexAttribP1ui = NULL;
PFNGLVERTEXATTRIBP1UIVPROC glad_glVertexAttribP1uiv = NULL;
PFNGLVERTEXATTRIBP2UIPROC glad_glVertexAttribP2ui = NULL;
PFNGLVERTEXATTRIBP2UIVPROC glad_glVertexAttribP2uiv = NULL;
PFNGLVERTEXATTRIBP3UIPROC glad_glVertexAttribP3ui = NULL;
PFNGLVERTEXATTRIBP3UIVPROC glad_glVertexAttribP3uiv = NULL;
PFNGLVERTEXATTRIBP4UIPROC glad_glVertexAttribP4ui = NULL;
PFNGLVERTEXATTRIBP4UIVPROC glad_glVertexAttribP4uiv = NULL;
PFNGLVERTEXATTRIBPOINTERPROC glad_glVertexAttribPointer = NULL;
PFNGLVERTEXBINDINGDIVISORPROC glad_glVertexBindingDivisor = NULL;
PFNGLVERTEXP2UIPROC glad_glVertexP2ui = NULL;
PFNGLVERTEXP2UIVPROC glad_glVertexP2uiv = NULL;
PFNGLVERTEXP3UIPROC glad_glVertexP3ui = NULL;
PFNGLVERTEXP3UIVPROC glad_glVertexP3uiv = NULL;
PFNGLVERTEXP4UIPROC glad_glVertexP4ui = NULL;
PFNGLVERTEXP4UIVPROC glad_glVertexP4uiv = NULL;
PFNGLVIEWPORTPROC glad_glViewport = NULL;
PFNGLVIEWPORTARRAYVPROC glad_glViewportArrayv = NULL;
PFNGLVIEWPORTINDEXEDFPROC glad_glViewportIndexedf = NULL;
PFNGLVIEWPORTINDEXEDFVPROC glad_glViewportIndexedfv = NULL;
PFNGLWAITSYNCPROC glad_glWaitSync = NULL;

static void load_GL_VERSION_1_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_0) return;
	glad_glCullFace = (PFNGLCULLFACEPROC)load("glCullFace");
	glad_glFrontFace = (PFNGLFRONTFACEPROC)load("glFrontFace");
	glad_glHint = (PFNGLHINTPROC)load("glHint");
	glad_glLineWidth = (PFNGLLINEWIDTHPROC)load("glLineWidth");
	glad_glPointSize = (PFNGLPOINTSIZEPROC)load("glPointSize");
	glad_glPolygonMode = (PFNGLPOLYGONMODEPROC)load("glPolygonMode");
	glad_glScissor = (PFNGLSCISSORPROC)load("glScissor");
	glad_glTexParameterf = (PFNGLTEXPARAMETERFPROC)load("glTexParameterf");
	glad_glTexParameterfv = (PFNGLTEXPARAMETERFVPROC)load("glTexParameterfv");
	glad_glTexParameteri = (PFNGLTEXPARAMETERIPROC)load("glTexParameteri");
	glad_glTexParameteriv = (PFNGLTEXPARAMETERIVPROC)load("glTexParameteriv");
	glad_glTexImage1D = (PFNGLTEXIMAGE1DPROC)load("glTexImage1D");
	glad_glTexImage2D = (PFNGLTEXIMAGE2DPROC)load("glTexImage2D");
	glad_glDrawBuffer = (PFNGLDRAWBUFFERPROC)load("glDrawBuffer");
	glad_glClear = (PFNGLCLEARPROC)load("glClear");
	glad_glClearColor = (PFNGLCLEARCOLORPROC)load("glClearColor");
	glad_glClearStencil = (PFNGLCLEARSTENCILPROC)load("glClearStencil");
	glad_glClearDepth = (PFNGLCLEARDEPTHPROC)load("glClearDepth");
	glad_glStencilMask = (PFNGLSTENCILMASKPROC)load("glStencilMask");
	glad_glColorMask = (PFNGLCOLORMASKPROC)load("glColorMask");
	glad_glDepthMask = (PFNGLDEPTHMASKPROC)load("glDepthMask");
	glad_glDisable = (PFNGLDISABLEPROC)load("glDisable");
	glad_glEnable = (PFNGLENABLEPROC)load("glEnable");
	glad_glFinish = (PFNGLFINISHPROC)load("glFinish");
	glad_glFlush = (PFNGLFLUSHPROC)load("glFlush");
	glad_glBlendFunc = (PFNGLBLENDFUNCPROC)load("glBlendFunc");
	glad_glLogicOp = (PFNGLLOGICOPPROC)load("glLogicOp");
	glad_glStencilFunc = (PFNGLSTENCILFUNCPROC)load("glStencilFunc");
	glad_glStencilOp = (PFNGLSTENCILOPPROC)load("glStencilOp");
	glad_glDepthFunc = (PFNGLDEPTHFUNCPROC)load("glDepthFunc");
	glad_glPixelStoref = (PFNGLPIXELSTOREFPROC)load("glPixelStoref");
	glad_glPixelStorei = (PFNGLPIXELSTOREIPROC)load("glPixelStorei");
	glad_glReadBuffer = (PFNGLREADBUFFERPROC)load("glReadBuffer");
	glad_glReadPixels = (PFNGLREADPIXELSPROC)load("glReadPixels");
	glad_glGetBooleanv = (PFNGLGETBOOLEANVPROC)load("glGetBooleanv");
	glad_glGetDoublev = (PFNGLGETDOUBLEVPROC)load("glGetDoublev");
	glad_glGetError = (PFNGLGETERRORPROC)load("glGetError");
	glad_glGetFloatv = (PFNGLGETFLOATVPROC)load("glGetFloatv");
	glad_glGetIntegerv = (PFNGLGETINTEGERVPROC)load("glGetIntegerv");
	glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
	glad_glGetTexImage = (PFNGLGETTEXIMAGEPROC)load("glGetTexImage");
	glad_glGetTexParameterfv = (PFNGLGETTEXPARAMETERFVPROC)load("glGetTexParameterfv");
	glad_glGetTexParameteriv = (PFNGLGETTEXPARAMETERIVPROC)load("glGetTexParameteriv");
	glad_glGetTexLevelParameterfv = (PFNGLGETTEXLEVELPARAMETERFVPROC)load("glGetTexLevelParameterfv");
	glad_glGetTexLevelParameteriv = (PFNGLGETTEXLEVELPARAMETERIVPROC)load("glGetTexLevelParameteriv");
	glad_glIsEnabled = (PFNGLISENABLEDPROC)load("glIsEnabled");
	glad_glDepthRange = (PFNGLDEPTHRANGEPROC)load("glDepthRange");
	glad_glViewport = (PFNGLVIEWPORTPROC)load("glViewport");
}
static void load_GL_VERSION_1_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_1) return;
	glad_glDrawArrays = (PFNGLDRAWARRAYSPROC)load("glDrawArrays");
	glad_glDrawElements = (PFNGLDRAWELEMENTSPROC)load("glDrawElements");
	glad_glPolygonOffset = (PFNGLPOLYGONOFFSETPROC)load("glPolygonOffset");
	glad_glCopyTexImage1D = (PFNGLCOPYTEXIMAGE1DPROC)load("glCopyTexImage1D");
	glad_glCopyTexImage2D = (PFNGLCOPYTEXIMAGE2DPROC)load("glCopyTexImage2D");
	glad_glCopyTexSubImage1D = (PFNGLCOPYTEXSUBIMAGE1DPROC)load("glCopyTexSubImage1D");
	glad_glCopyTexSubImage2D = (PFNGLCOPYTEXSUBIMAGE2DPROC)load("glCopyTexSubImage2D");
	glad_glTexSubImage1D = (PFNGLTEXSUBIMAGE1DPROC)load("glTexSubImage1D");
	glad_glTexSubImage2D = (PFNGLTEXSUBIMAGE2DPROC)load("glTexSubImage2D");
	glad_glBindTexture = (PFNGLBINDTEXTUREPROC)load("glBindTexture");
	glad_glDeleteTextures = (PFNGLDELETETEXTURESPROC)load("glDeleteTextures");
	glad_glGenTextures = (PFNGLGENTEXTURESPROC)load("glGenTextures");
	glad_glIsTexture = (PFNGLISTEXTUREPROC)load("glIsTexture");
}
static void load_GL_VERSION_1_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_2) return;
	glad_glDrawRangeElements = (PFNGLDRAWRANGEELEMENTSPROC)load("glDrawRangeElements");
	glad_glTexImage3D = (PFNGLTEXIMAGE3DPROC)load("glTexImage3D");
	glad_glTexSubImage3D = (PFNGLTEXSUBIMAGE3DPROC)load("glTexSubImage3D");
	glad_glCopyTexSubImage3D = (PFNGLCOPYTEXSUBIMAGE3DPROC)load("glCopyTexSubImage3D");
}
static void load_GL_VERSION_1_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_3) return;
	glad_glActiveTexture = (PFNGLACTIVETEXTUREPROC)load("glActiveTexture");
	glad_glSampleCoverage = (PFNGLSAMPLECOVERAGEPROC)load("glSampleCoverage");
	glad_glCompressedTexImage3D = (PFNGLCOMPRESSEDTEXIMAGE3DPROC)load("glCompressedTexImage3D");
	glad_glCompressedTexImage2D = (PFNGLCOMPRESSEDTEXIMAGE2DPROC)load("glCompressedTexImage2D");
	glad_glCompressedTexImage1D = (PFNGLCOMPRESSEDTEXIMAGE1DPROC)load("glCompressedTexImage1D");
	glad_glCompressedTexSubImage3D = (PFNGLCOMPRESSEDTEXSUBIMAGE3DPROC)load("glCompressedTexSubImage3D");
	glad_glCompressedTexSubImage2D = (PFNGLCOMPRESSEDTEXSUBIMAGE2DPROC)load("glCompressedTexSubImage2D");
	glad_glCompressedTexSubImage1D = (PFNGLCOMPRESSEDTEXSUBIMAGE1DPROC)load("glCompressedTexSubImage1D");
	glad_glGetCompressedTexImage = (PFNGLGETCOMPRESSEDTEXIMAGEPROC)load("glGetCompressedTexImage");
}
static void load_GL_VERSION_1_4(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_4) return;
	glad_glBlendFuncSeparate = (PFNGLBLENDFUNCSEPARATEPROC)load("glBlendFuncSeparate");
	glad_glMultiDrawArrays = (PFNGLMULTIDRAWARRAYSPROC)load("glMultiDrawArrays");
	glad_glMultiDrawElements = (PFNGLMULTIDRAWELEMENTSPROC)load("glMultiDrawElements");
	glad_glPointParameterf = (PFNGLPOINTPARAMETERFPROC)load("glPointParameterf");
	glad_glPointParameterfv = (PFNGLPOINTPARAMETERFVPROC)load("glPointParameterfv");
	glad_glPointParameteri = (PFNGLPOINTPARAMETERIPROC)load("glPointParameteri");
	glad_glPointParameteriv = (PFNGLPOINTPARAMETERIVPROC)load("glPointParameteriv");
	glad_glBlendColor = (PFNGLBLENDCOLORPROC)load("glBlendColor");
	glad_glBlendEquation = (PFNGLBLENDEQUATIONPROC)load("glBlendEquation");
}
static void load_GL_VERSION_1_5(GLADloadproc load) {
	if(!GLAD_GL_VERSION_1_5) return;
	glad_glGenQueries = (PFNGLGENQUERIESPROC)load("glGenQueries");
	glad_glDeleteQueries = (PFNGLDELETEQUERIESPROC)load("glDeleteQueries");
	glad_glIsQuery = (PFNGLISQUERYPROC)load("glIsQuery");
	glad_glBeginQuery = (PFNGLBEGINQUERYPROC)load("glBeginQuery");
	glad_glEndQuery = (PFNGLENDQUERYPROC)load("glEndQuery");
	glad_glGetQueryiv = (PFNGLGETQUERYIVPROC)load("glGetQueryiv");
	glad_glGetQueryObjectiv = (PFNGLGETQUERYOBJECTIVPROC)load("glGetQueryObjectiv");
	glad_glGetQueryObjectuiv = (PFNGLGETQUERYOBJECTUIVPROC)load("glGetQueryObjectuiv");
	glad_glBindBuffer = (PFNGLBINDBUFFERPROC)load("glBindBuffer");
	glad_glDeleteBuffers = (PFNGLDELETEBUFFERSPROC)load("glDeleteBuffers");
	glad_glGenBuffers = (PFNGLGENBUFFERSPROC)load("glGenBuffers");
	glad_glIsBuffer = (PFNGLISBUFFERPROC)load("glIsBuffer");
	glad_glBufferData = (PFNGLBUFFERDATAPROC)load("glBufferData");
	glad_glBufferSubData = (PFNGLBUFFERSUBDATAPROC)load("glBufferSubData");
	glad_glGetBufferSubData = (PFNGLGETBUFFERSUBDATAPROC)load("glGetBufferSubData");
	glad_glMapBuffer = (PFNGLMAPBUFFERPROC)load("glMapBuffer");
	glad_glUnmapBuffer = (PFNGLUNMAPBUFFERPROC)load("glUnmapBuffer");
	glad_glGetBufferParameteriv = (PFNGLGETBUFFERPARAMETERIVPROC)load("glGetBufferParameteriv");
	glad_glGetBufferPointerv = (PFNGLGETBUFFERPOINTERVPROC)load("glGetBufferPointerv");
}
static void load_GL_VERSION_2_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_2_0) return;
	glad_glBlendEquationSeparate = (PFNGLBLENDEQUATIONSEPARATEPROC)load("glBlendEquationSeparate");
	glad_glDrawBuffers = (PFNGLDRAWBUFFERSPROC)load("glDrawBuffers");
	glad_glStencilOpSeparate = (PFNGLSTENCILOPSEPARATEPROC)load("glStencilOpSeparate");
	glad_glStencilFuncSeparate = (PFNGLSTENCILFUNCSEPARATEPROC)load("glStencilFuncSeparate");
	glad_glStencilMaskSeparate = (PFNGLSTENCILMASKSEPARATEPROC)load("glStencilMaskSeparate");
	glad_glAttachShader = (PFNGLATTACHSHADERPROC)load("glAttachShader");
	glad_glBindAttribLocation = (PFNGLBINDATTRIBLOCATIONPROC)load("glBindAttribLocation");
	glad_glCompileShader = (PFNGLCOMPILESHADERPROC)load("glCompileShader");
	glad_glCreateProgram = (PFNGLCREATEPROGRAMPROC)load("glCreateProgram");
	glad_glCreateShader = (PFNGLCREATESHADERPROC)load("glCreateShader");
	glad_glDeleteProgram = (PFNGLDELETEPROGRAMPROC)load("glDeleteProgram");
	glad_glDeleteShader = (PFNGLDELETESHADERPROC)load("glDeleteShader");
	glad_glDetachShader = (PFNGLDETACHSHADERPROC)load("glDetachShader");
	glad_glDisableVertexAttribArray = (PFNGLDISABLEVERTEXATTRIBARRAYPROC)load("glDisableVertexAttribArray");
	glad_glEnableVertexAttribArray = (PFNGLENABLEVERTEXATTRIBARRAYPROC)load("glEnableVertexAttribArray");
	glad_glGetActiveAttrib = (PFNGLGETACTIVEATTRIBPROC)load("glGetActiveAttrib");
	glad_glGetActiveUniform = (PFNGLGETACTIVEUNIFORMPROC)load("glGetActiveUniform");
	glad_glGetAttachedShaders = (PFNGLGETATTACHEDSHADERSPROC)load("glGetAttachedShaders");
	glad_glGetAttribLocation = (PFNGLGETATTRIBLOCATIONPROC)load("glGetAttribLocation");
	glad_glGetProgramiv = (PFNGLGETPROGRAMIVPROC)load("glGetProgramiv");
	glad_glGetProgramInfoLog = (PFNGLGETPROGRAMINFOLOGPROC)load("glGetProgramInfoLog");
	glad_glGetShaderiv = (PFNGLGETSHADERIVPROC)load("glGetShaderiv");
	glad_glGetShaderInfoLog = (PFNGLGETSHADERINFOLOGPROC)load("glGetShaderInfoLog");
	glad_glGetShaderSource = (PFNGLGETSHADERSOURCEPROC)load("glGetShaderSource");
	glad_glGetUniformLocation = (PFNGLGETUNIFORMLOCATIONPROC)load("glGetUniformLocation");
	glad_glGetUniformfv = (PFNGLGETUNIFORMFVPROC)load("glGetUniformfv");
	glad_glGetUniformiv = (PFNGLGETUNIFORMIVPROC)load("glGetUniformiv");
	glad_glGetVertexAttribdv = (PFNGLGETVERTEXATTRIBDVPROC)load("glGetVertexAttribdv");
	glad_glGetVertexAttribfv = (PFNGLGETVERTEXATTRIBFVPROC)load("glGetVertexAttribfv");
	glad_glGetVertexAttribiv = (PFNGLGETVERTEXATTRIBIVPROC)load("glGetVertexAttribiv");
	glad_glGetVertexAttribPointerv = (PFNGLGETVERTEXATTRIBPOINTERVPROC)load("glGetVertexAttribPointerv");
	glad_glIsProgram = (PFNGLISPROGRAMPROC)load("glIsProgram");
	glad_glIsShader = (PFNGLISSHADERPROC)load("glIsShader");
	glad_glLinkProgram = (PFNGLLINKPROGRAMPROC)load("glLinkProgram");
	glad_glShaderSource = (PFNGLSHADERSOURCEPROC)load("glShaderSource");
	glad_glUseProgram = (PFNGLUSEPROGRAMPROC)load("glUseProgram");
	glad_glUniform1f = (PFNGLUNIFORM1FPROC)load("glUniform1f");
	glad_glUniform2f = (PFNGLUNIFORM2FPROC)load("glUniform2f");
	glad_glUniform3f = (PFNGLUNIFORM3FPROC)load("glUniform3f");
	glad_glUniform4f = (PFNGLUNIFORM4FPROC)load("glUniform4f");
	glad_glUniform1i = (PFNGLUNIFORM1IPROC)load("glUniform1i");
	glad_glUniform2i = (PFNGLUNIFORM2IPROC)load("glUniform2i");
	glad_glUniform3i = (PFNGLUNIFORM3IPROC)load("glUniform3i");
	glad_glUniform4i = (PFNGLUNIFORM4IPROC)load("glUniform4i");
	glad_glUniform1fv = (PFNGLUNIFORM1FVPROC)load("glUniform1fv");
	glad_glUniform2fv = (PFNGLUNIFORM2FVPROC)load("glUniform2fv");
	glad_glUniform3fv = (PFNGLUNIFORM3FVPROC)load("glUniform3fv");
	glad_glUniform4fv = (PFNGLUNIFORM4FVPROC)load("glUniform4fv");
	glad_glUniform1iv = (PFNGLUNIFORM1IVPROC)load("glUniform1iv");
	glad_glUniform2iv = (PFNGLUNIFORM2IVPROC)load("glUniform2iv");
	glad_glUniform3iv = (PFNGLUNIFORM3IVPROC)load("glUniform3iv");
	glad_glUniform4iv = (PFNGLUNIFORM4IVPROC)load("glUniform4iv");
	glad_glUniformMatrix2fv = (PFNGLUNIFORMMATRIX2FVPROC)load("glUniformMatrix2fv");
	glad_glUniformMatrix3fv = (PFNGLUNIFORMMATRIX3FVPROC)load("glUniformMatrix3fv");
	glad_glUniformMatrix4fv = (PFNGLUNIFORMMATRIX4FVPROC)load("glUniformMatrix4fv");
	glad_glValidateProgram = (PFNGLVALIDATEPROGRAMPROC)load("glValidateProgram");
	glad_glVertexAttrib1d = (PFNGLVERTEXATTRIB1DPROC)load("glVertexAttrib1d");
	glad_glVertexAttrib1dv = (PFNGLVERTEXATTRIB1DVPROC)load("glVertexAttrib1dv");
	glad_glVertexAttrib1f = (PFNGLVERTEXATTRIB1FPROC)load("glVertexAttrib1f");
	glad_glVertexAttrib1fv = (PFNGLVERTEXATTRIB1FVPROC)load("glVertexAttrib1fv");
	glad_glVertexAttrib1s = (PFNGLVERTEXATTRIB1SPROC)load("glVertexAttrib1s");
	glad_glVertexAttrib1sv = (PFNGLVERTEXATTRIB1SVPROC)load("glVertexAttrib1sv");
	glad_glVertexAttrib2d = (PFNGLVERTEXATTRIB2DPROC)load("glVertexAttrib2d");
	glad_glVertexAttrib2dv = (PFNGLVERTEXATTRIB2DVPROC)load("glVertexAttrib2dv");
	glad_glVertexAttrib2f = (PFNGLVERTEXATTRIB2FPROC)load("glVertexAttrib2f");
	glad_glVertexAttrib2fv = (PFNGLVERTEXATTRIB2FVPROC)load("glVertexAttrib2fv");
	glad_glVertexAttrib2s = (PFNGLVERTEXATTRIB2SPROC)load("glVertexAttrib2s");
	glad_glVertexAttrib2sv = (PFNGLVERTEXATTRIB2SVPROC)load("glVertexAttrib2sv");
	glad_glVertexAttrib3d = (PFNGLVERTEXATTRIB3DPROC)load("glVertexAttrib3d");
	glad_glVertexAttrib3dv = (PFNGLVERTEXATTRIB3DVPROC)load("glVertexAttrib3dv");
	glad_glVertexAttrib3f = (PFNGLVERTEXATTRIB3FPROC)load("glVertexAttrib3f");
	glad_glVertexAttrib3fv = (PFNGLVERTEXATTRIB3FVPROC)load("glVertexAttrib3fv");
	glad_glVertexAttrib3s = (PFNGLVERTEXATTRIB3SPROC)load("glVertexAttrib3s");
	glad_glVertexAttrib3sv = (PFNGLVERTEXATTRIB3SVPROC)load("glVertexAttrib3sv");
	glad_glVertexAttrib4Nbv = (PFNGLVERTEXATTRIB4NBVPROC)load("glVertexAttrib4Nbv");
	glad_glVertexAttrib4Niv = (PFNGLVERTEXATTRIB4NIVPROC)load("glVertexAttrib4Niv");
	glad_glVertexAttrib4Nsv = (PFNGLVERTEXATTRIB4NSVPROC)load("glVertexAttrib4Nsv");
	glad_glVertexAttrib4Nub = (PFNGLVERTEXATTRIB4NUBPROC)load("glVertexAttrib4Nub");
	glad_glVertexAttrib4Nubv = (PFNGLVERTEXATTRIB4NUBVPROC)load("glVertexAttrib4Nubv");
	glad_glVertexAttrib4Nuiv = (PFNGLVERTEXATTRIB4NUIVPROC)load("glVertexAttrib4Nuiv");
	glad_glVertexAttrib4Nusv = (PFNGLVERTEXATTRIB4NUSVPROC)load("glVertexAttrib4Nusv");
	glad_glVertexAttrib4bv = (PFNGLVERTEXATTRIB4BVPROC)load("glVertexAttrib4bv");
	glad_glVertexAttrib4d = (PFNGLVERTEXATTRIB4DPROC)load("glVertexAttrib4d");
	glad_glVertexAttrib4dv = (PFNGLVERTEXATTRIB4DVPROC)load("glVertexAttrib4dv");
	glad_glVertexAttrib4f = (PFNGLVERTEXATTRIB4FPROC)load("glVertexAttrib4f");
	glad_glVertexAttrib4fv = (PFNGLVERTEXATTRIB4FVPROC)load("glVertexAttrib4fv");
	glad_glVertexAttrib4iv = (PFNGLVERTEXATTRIB4IVPROC)load("glVertexAttrib4iv");
	glad_glVertexAttrib4s = (PFNGLVERTEXATTRIB4SPROC)load("glVertexAttrib4s");
	glad_glVertexAttrib4sv = (PFNGLVERTEXATTRIB4SVPROC)load("glVertexAttrib4sv");
	glad_glVertexAttrib4ubv = (PFNGLVERTEXATTRIB4UBVPROC)load("glVertexAttrib4ubv");
	glad_glVertexAttrib4uiv = (PFNGLVERTEXATTRIB4UIVPROC)load("glVertexAttrib4uiv");
	glad_glVertexAttrib4usv = (PFNGLVERTEXATTRIB4USVPROC)load("glVertexAttrib4usv");
	glad_glVertexAttribPointer = (PFNGLVERTEXATTRIBPOINTERPROC)load("glVertexAttribPointer");
}
static void load_GL_VERSION_2_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_2_1) return;
	glad_glUniformMatrix2x3fv = (PFNGLUNIFORMMATRIX2X3FVPROC)load("glUniformMatrix2x3fv");
	glad_glUniformMatrix3x2fv = (PFNGLUNIFORMMATRIX3X2FVPROC)load("glUniformMatrix3x2fv");
	glad_glUniformMatrix2x4fv = (PFNGLUNIFORMMATRIX2X4FVPROC)load("glUniformMatrix2x4fv");
	glad_glUniformMatrix4x2fv = (PFNGLUNIFORMMATRIX4X2FVPROC)load("glUniformMatrix4x2fv");
	glad_glUniformMatrix3x4fv = (PFNGLUNIFORMMATRIX3X4FVPROC)load("glUniformMatrix3x4fv");
	glad_glUniformMatrix4x3fv = (PFNGLUNIFORMMATRIX4X3FVPROC)load("glUniformMatrix4x3fv");
}
static void load_GL_VERSION_3_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_0) return;
	glad_glColorMaski = (PFNGLCOLORMASKIPROC)load("glColorMaski");
	glad_glGetBooleani_v = (PFNGLGETBOOLEANI_VPROC)load("glGetBooleani_v");
	glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
	glad_glEnablei = (PFNGLENABLEIPROC)load("glEnablei");
	glad_glDisablei = (PFNGLDISABLEIPROC)load("glDisablei");
	glad_glIsEnabledi = (PFNGLISENABLEDIPROC)load("glIsEnabledi");
	glad_glBeginTransformFeedback = (PFNGLBEGINTRANSFORMFEEDBACKPROC)load("glBeginTransformFeedback");
	glad_glEndTransformFeedback = (PFNGLENDTRANSFORMFEEDBACKPROC)load("glEndTransformFeedback");
	glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
	glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
	glad_glTransformFeedbackVaryings = (PFNGLTRANSFORMFEEDBACKVARYINGSPROC)load("glTransformFeedbackVaryings");
	glad_glGetTransformFeedbackVarying = (PFNGLGETTRANSFORMFEEDBACKVARYINGPROC)load("glGetTransformFeedbackVarying");
	glad_glClampColor = (PFNGLCLAMPCOLORPROC)load("glClampColor");
	glad_glBeginConditionalRender = (PFNGLBEGINCONDITIONALRENDERPROC)load("glBeginConditionalRender");
	glad_glEndConditionalRender = (PFNGLENDCONDITIONALRENDERPROC)load("glEndConditionalRender");
	glad_glVertexAttribIPointer = (PFNGLVERTEXATTRIBIPOINTERPROC)load("glVertexAttribIPointer");
	glad_glGetVertexAttribIiv = (PFNGLGETVERTEXATTRIBIIVPROC)load("glGetVertexAttribIiv");
	glad_glGetVertexAttribIuiv = (PFNGLGETVERTEXATTRIBIUIVPROC)load("glGetVertexAttribIuiv");
	glad_glVertexAttribI1i = (PFNGLVERTEXATTRIBI1IPROC)load("glVertexAttribI1i");
	glad_glVertexAttribI2i = (PFNGLVERTEXATTRIBI2IPROC)load("glVertexAttribI2i");
	glad_glVertexAttribI3i = (PFNGLVERTEXATTRIBI3IPROC)load("glVertexAttribI3i");
	glad_glVertexAttribI4i = (PFNGLVERTEXATTRIBI4IPROC)load("glVertexAttribI4i");
	glad_glVertexAttribI1ui = (PFNGLVERTEXATTRIBI1UIPROC)load("glVertexAttribI1ui");
	glad_glVertexAttribI2ui = (PFNGLVERTEXATTRIBI2UIPROC)load("glVertexAttribI2ui");
	glad_glVertexAttribI3ui = (PFNGLVERTEXATTRIBI3UIPROC)load("glVertexAttribI3ui");
	glad_glVertexAttribI4ui = (PFNGLVERTEXATTRIBI4UIPROC)load("glVertexAttribI4ui");
	glad_glVertexAttribI1iv = (PFNGLVERTEXATTRIBI1IVPROC)load("glVertexAttribI1iv");
	glad_glVertexAttribI2iv = (PFNGLVERTEXATTRIBI2IVPROC)load("glVertexAttribI2iv");
	glad_glVertexAttribI3iv = (PFNGLVERTEXATTRIBI3IVPROC)load("glVertexAttribI3iv");
	glad_glVertexAttribI4iv = (PFNGLVERTEXATTRIBI4IVPROC)load("glVertexAttribI4iv");
	glad_glVertexAttribI1uiv = (PFNGLVERTEXATTRIBI1UIVPROC)load("glVertexAttribI1uiv");
	glad_glVertexAttribI2uiv = (PFNGLVERTEXATTRIBI2UIVPROC)load("glVertexAttribI2uiv");
	glad_glVertexAttribI3uiv = (PFNGLVERTEXATTRIBI3UIVPROC)load("glVertexAttribI3uiv");
	glad_glVertexAttribI4uiv = (PFNGLVERTEXATTRIBI4UIVPROC)load("glVertexAttribI4uiv");
	glad_glVertexAttribI4bv = (PFNGLVERTEXATTRIBI4BVPROC)load("glVertexAttribI4bv");
	glad_glVertexAttribI4sv = (PFNGLVERTEXATTRIBI4SVPROC)load("glVertexAttribI4sv");
	glad_glVertexAttribI4ubv = (PFNGLVERTEXATTRIBI4UBVPROC)load("glVertexAttribI4ubv");
	glad_glVertexAttribI4usv = (PFNGLVERTEXATTRIBI4USVPROC)load("glVertexAttribI4usv");
	glad_glGetUniformuiv = (PFNGLGETUNIFORMUIVPROC)load("glGetUniformuiv");
	glad_glBindFragDataLocation = (PFNGLBINDFRAGDATALOCATIONPROC)load("glBindFragDataLocation");
	glad_glGetFragDataLocation = (PFNGLGETFRAGDATALOCATIONPROC)load("glGetFragDataLocation");
	glad_glUniform1ui = (PFNGLUNIFORM1UIPROC)load("glUniform1ui");
	glad_glUniform2ui = (PFNGLUNIFORM2UIPROC)load("glUniform2ui");
	glad_glUniform3ui = (PFNGLUNIFORM3UIPROC)load("glUniform3ui");
	glad_glUniform4ui = (PFNGLUNIFORM4UIPROC)load("glUniform4ui");
	glad_glUniform1uiv = (PFNGLUNIFORM1UIVPROC)load("glUniform1uiv");
	glad_glUniform2uiv = (PFNGLUNIFORM2UIVPROC)load("glUniform2uiv");
	glad_glUniform3uiv = (PFNGLUNIFORM3UIVPROC)load("glUniform3uiv");
	glad_glUniform4uiv = (PFNGLUNIFORM4UIVPROC)load("glUniform4uiv");
	glad_glTexParameterIiv = (PFNGLTEXPARAMETERIIVPROC)load("glTexParameterIiv");
	glad_glTexParameterIuiv = (PFNGLTEXPARAMETERIUIVPROC)load("glTexParameterIuiv");
	glad_glGetTexParameterIiv = (PFNGLGETTEXPARAMETERIIVPROC)load("glGetTexParameterIiv");
	glad_glGetTexParameterIuiv = (PFNGLGETTEXPARAMETERIUIVPROC)load("glGetTexParameterIuiv");
	glad_glClearBufferiv = (PFNGLCLEARBUFFERIVPROC)load("glClearBufferiv");
	glad_glClearBufferuiv = (PFNGLCLEARBUFFERUIVPROC)load("glClearBufferuiv");
	glad_glClearBufferfv = (PFNGLCLEARBUFFERFVPROC)load("glClearBufferfv");
	glad_glClearBufferfi = (PFNGLCLEARBUFFERFIPROC)load("glClearBufferfi");
	glad_glGetStringi = (PFNGLGETSTRINGIPROC)load("glGetStringi");
	glad_glIsRenderbuffer = (PFNGLISRENDERBUFFERPROC)load("glIsRenderbuffer");
	glad_glBindRenderbuffer = (PFNGLBINDRENDERBUFFERPROC)load("glBindRenderbuffer");
	glad_glDeleteRenderbuffers = (PFNGLDELETERENDERBUFFERSPROC)load("glDeleteRenderbuffers");
	glad_glGenRenderbuffers = (PFNGLGENRENDERBUFFERSPROC)load("glGenRenderbuffers");
	glad_glRenderbufferStorage = (PFNGLRENDERBUFFERSTORAGEPROC)load("glRenderbufferStorage");
	glad_glGetRenderbufferParameteriv = (PFNGLGETRENDERBUFFERPARAMETERIVPROC)load("glGetRenderbufferParameteriv");
	glad_glIsFramebuffer = (PFNGLISFRAMEBUFFERPROC)load("glIsFramebuffer");
	glad_glBindFramebuffer = (PFNGLBINDFRAMEBUFFERPROC)load("glBindFramebuffer");
	glad_glDeleteFramebuffers = (PFNGLDELETEFRAMEBUFFERSPROC)load("glDeleteFramebuffers");
	glad_glGenFramebuffers = (PFNGLGENFRAMEBUFFERSPROC)load("glGenFramebuffers");
	glad_glCheckFramebufferStatus = (PFNGLCHECKFRAMEBUFFERSTATUSPROC)load("glCheckFramebufferStatus");
	glad_glFramebufferTexture1D = (PFNGLFRAMEBUFFERTEXTURE1DPROC)load("glFramebufferTexture1D");
	glad_glFramebufferTexture2D = (PFNGLFRAMEBUFFERTEXTURE2DPROC)load("glFramebufferTexture2D");
	glad_glFramebufferTexture3D = (PFNGLFRAMEBUFFERTEXTURE3DPROC)load("glFramebufferTexture3D");
	glad_glFramebufferRenderbuffer = (PFNGLFRAMEBUFFERRENDERBUFFERPROC)load("glFramebufferRenderbuffer");
	glad_glGetFramebufferAttachmentParameteriv = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetFramebufferAttachmentParameteriv");
	glad_glGenerateMipmap = (PFNGLGENERATEMIPMAPPROC)load("glGenerateMipmap");
	glad_glBlitFramebuffer = (PFNGLBLITFRAMEBUFFERPROC)load("glBlitFramebuffer");
	glad_glRenderbufferStorageMultisample = (PFNGLRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glRenderbufferStorageMultisample");
	glad_glFramebufferTextureLayer = (PFNGLFRAMEBUFFERTEXTURELAYERPROC)load("glFramebufferTextureLayer");
	glad_glMapBufferRange = (PFNGLMAPBUFFERRANGEPROC)load("glMapBufferRange");
	glad_glFlushMappedBufferRange = (PFNGLFLUSHMAPPEDBUFFERRANGEPROC)load("glFlushMappedBufferRange");
	glad_glBindVertexArray = (PFNGLBINDVERTEXARRAYPROC)load("glBindVertexArray");
	glad_glDeleteVertexArrays = (PFNGLDELETEVERTEXARRAYSPROC)load("glDeleteVertexArrays");
	glad_glGenVertexArrays = (PFNGLGENVERTEXARRAYSPROC)load("glGenVertexArrays");
	glad_glIsVertexArray = (PFNGLISVERTEXARRAYPROC)load("glIsVertexArray");
}
static void load_GL_VERSION_3_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_1) return;
	glad_glDrawArraysInstanced = (PFNGLDRAWARRAYSINSTANCEDPROC)load("glDrawArraysInstanced");
	glad_glDrawElementsInstanced = (PFNGLDRAWELEMENTSINSTANCEDPROC)load("glDrawElementsInstanced");
	glad_glTexBuffer = (PFNGLTEXBUFFERPROC)load("glTexBuffer");
	glad_glPrimitiveRestartIndex = (PFNGLPRIMITIVERESTARTINDEXPROC)load("glPrimitiveRestartIndex");
	glad_glCopyBufferSubData = (PFNGLCOPYBUFFERSUBDATAPROC)load("glCopyBufferSubData");
	glad_glGetUniformIndices = (PFNGLGETUNIFORMINDICESPROC)load("glGetUniformIndices");
	glad_glGetActiveUniformsiv = (PFNGLGETACTIVEUNIFORMSIVPROC)load("glGetActiveUniformsiv");
	glad_glGetActiveUniformName = (PFNGLGETACTIVEUNIFORMNAMEPROC)load("glGetActiveUniformName");
	glad_glGetUniformBlockIndex = (PFNGLGETUNIFORMBLOCKINDEXPROC)load("glGetUniformBlockIndex");
	glad_glGetActiveUniformBlockiv = (PFNGLGETACTIVEUNIFORMBLOCKIVPROC)load("glGetActiveUniformBlockiv");
	glad_glGetActiveUniformBlockName = (PFNGLGETACTIVEUNIFORMBLOCKNAMEPROC)load("glGetActiveUniformBlockName");
	glad_glUniformBlockBinding = (PFNGLUNIFORMBLOCKBINDINGPROC)load("glUniformBlockBinding");
	glad_glBindBufferRange = (PFNGLBINDBUFFERRANGEPROC)load("glBindBufferRange");
	glad_glBindBufferBase = (PFNGLBINDBUFFERBASEPROC)load("glBindBufferBase");
	glad_glGetIntegeri_v = (PFNGLGETINTEGERI_VPROC)load("glGetIntegeri_v");
}
static void load_GL_VERSION_3_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_2) return;
	glad_glDrawElementsBaseVertex = (PFNGLDRAWELEMENTSBASEVERTEXPROC)load("glDrawElementsBaseVertex");
	glad_glDrawRangeElementsBaseVertex = (PFNGLDRAWRANGEELEMENTSBASEVERTEXPROC)load("glDrawRangeElementsBaseVertex");
	glad_glDrawElementsInstancedBaseVertex = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXPROC)load("glDrawElementsInstancedBaseVertex");
	glad_glMultiDrawElementsBaseVertex = (PFNGLMULTIDRAWELEMENTSBASEVERTEXPROC)load("glMultiDrawElementsBaseVertex");
	glad_glProvokingVertex = (PFNGLPROVOKINGVERTEXPROC)load("glProvokingVertex");
	glad_glFenceSync = (PFNGLFENCESYNCPROC)load("glFenceSync");
	glad_glIsSync = (PFNGLISSYNCPROC)load("glIsSync");
	glad_glDeleteSync = (PFNGLDELETESYNCPROC)load("glDeleteSync");
	glad_glClientWaitSync = (PFNGLCLIENTWAITSYNCPROC)load("glClientWaitSync");
	glad_glWaitSync = (PFNGLWAITSYNCPROC)load("glWaitSync");
	glad_glGetInteger64v = (PFNGLGETINTEGER64VPROC)load("glGetInteger64v");
	glad_glGetSynciv = (PFNGLGETSYNCIVPROC)load("glGetSynciv");
	glad_glGetInteger64i_v = (PFNGLGETINTEGER64I_VPROC)load("glGetInteger64i_v");
	glad_glGetBufferParameteri64v = (PFNGLGETBUFFERPARAMETERI64VPROC)load("glGetBufferParameteri64v");
	glad_glFramebufferTexture = (PFNGLFRAMEBUFFERTEXTUREPROC)load("glFramebufferTexture");
	glad_glTexImage2DMultisample = (PFNGLTEXIMAGE2DMULTISAMPLEPROC)load("glTexImage2DMultisample");
	glad_glTexImage3DMultisample = (PFNGLTEXIMAGE3DMULTISAMPLEPROC)load("glTexImage3DMultisample");
	glad_glGetMultisamplefv = (PFNGLGETMULTISAMPLEFVPROC)load("glGetMultisamplefv");
	glad_glSampleMaski = (PFNGLSAMPLEMASKIPROC)load("glSampleMaski");
}
static void load_GL_VERSION_3_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_3_3) return;
	glad_glBindFragDataLocationIndexed = (PFNGLBINDFRAGDATALOCATIONINDEXEDPROC)load("glBindFragDataLocationIndexed");
	glad_glGetFragDataIndex = (PFNGLGETFRAGDATAINDEXPROC)load("glGetFragDataIndex");
	glad_glGenSamplers = (PFNGLGENSAMPLERSPROC)load("glGenSamplers");
	glad_glDeleteSamplers = (PFNGLDELETESAMPLERSPROC)load("glDeleteSamplers");
	glad_glIsSampler = (PFNGLISSAMPLERPROC)load("glIsSampler");
	glad_glBindSampler = (PFNGLBINDSAMPLERPROC)load("glBindSampler");
	glad_glSamplerParameteri = (PFNGLSAMPLERPARAMETERIPROC)load("glSamplerParameteri");
	glad_glSamplerParameteriv = (PFNGLSAMPLERPARAMETERIVPROC)load("glSamplerParameteriv");
	glad_glSamplerParameterf = (PFNGLSAMPLERPARAMETERFPROC)load("glSamplerParameterf");
	glad_glSamplerParameterfv = (PFNGLSAMPLERPARAMETERFVPROC)load("glSamplerParameterfv");
	glad_glSamplerParameterIiv = (PFNGLSAMPLERPARAMETERIIVPROC)load("glSamplerParameterIiv");
	glad_glSamplerParameterIuiv = (PFNGLSAMPLERPARAMETERIUIVPROC)load("glSamplerParameterIuiv");
	glad_glGetSamplerParameteriv = (PFNGLGETSAMPLERPARAMETERIVPROC)load("glGetSamplerParameteriv");
	glad_glGetSamplerParameterIiv = (PFNGLGETSAMPLERPARAMETERIIVPROC)load("glGetSamplerParameterIiv");
	glad_glGetSamplerParameterfv = (PFNGLGETSAMPLERPARAMETERFVPROC)load("glGetSamplerParameterfv");
	glad_glGetSamplerParameterIuiv = (PFNGLGETSAMPLERPARAMETERIUIVPROC)load("glGetSamplerParameterIuiv");
	glad_glQueryCounter = (PFNGLQUERYCOUNTERPROC)load("glQueryCounter");
	glad_glGetQueryObjecti64v = (PFNGLGETQUERYOBJECTI64VPROC)load("glGetQueryObjecti64v");
	glad_glGetQueryObjectui64v = (PFNGLGETQUERYOBJECTUI64VPROC)load("glGetQueryObjectui64v");
	glad_glVertexAttribDivisor = (PFNGLVERTEXATTRIBDIVISORPROC)load("glVertexAttribDivisor");
	glad_glVertexAttribP1ui = (PFNGLVERTEXATTRIBP1UIPROC)load("glVertexAttribP1ui");
	glad_glVertexAttribP1uiv = (PFNGLVERTEXATTRIBP1UIVPROC)load("glVertexAttribP1uiv");
	glad_glVertexAttribP2ui = (PFNGLVERTEXATTRIBP2UIPROC)load("glVertexAttribP2ui");
	glad_glVertexAttribP2uiv = (PFNGLVERTEXATTRIBP2UIVPROC)load("glVertexAttribP2uiv");
	glad_glVertexAttribP3ui = (PFNGLVERTEXATTRIBP3UIPROC)load("glVertexAttribP3ui");
	glad_glVertexAttribP3uiv = (PFNGLVERTEXATTRIBP3UIVPROC)load("glVertexAttribP3uiv");
	glad_glVertexAttribP4ui = (PFNGLVERTEXATTRIBP4UIPROC)load("glVertexAttribP4ui");
	glad_glVertexAttribP4uiv = (PFNGLVERTEXATTRIBP4UIVPROC)load("glVertexAttribP4uiv");
	glad_glVertexP2ui = (PFNGLVERTEXP2UIPROC)load("glVertexP2ui");
	glad_glVertexP2uiv = (PFNGLVERTEXP2UIVPROC)load("glVertexP2uiv");
	glad_glVertexP3ui = (PFNGLVERTEXP3UIPROC)load("glVertexP3ui");
	glad_glVertexP3uiv = (PFNGLVERTEXP3UIVPROC)load("glVertexP3uiv");
	glad_glVertexP4ui = (PFNGLVERTEXP4UIPROC)load("glVertexP4ui");
	glad_glVertexP4uiv = (PFNGLVERTEXP4UIVPROC)load("glVertexP4uiv");
	glad_glTexCoordP1ui = (PFNGLTEXCOORDP1UIPROC)load("glTexCoordP1ui");
	glad_glTexCoordP1uiv = (PFNGLTEXCOORDP1UIVPROC)load("glTexCoordP1uiv");
	glad_glTexCoordP2ui = (PFNGLTEXCOORDP2UIPROC)load("glTexCoordP2ui");
	glad_glTexCoordP2uiv = (PFNGLTEXCOORDP2UIVPROC)load("glTexCoordP2uiv");
	glad_glTexCoordP3ui = (PFNGLTEXCOORDP3UIPROC)load("glTexCoordP3ui");
	glad_glTexCoordP3uiv = (PFNGLTEXCOORDP3UIVPROC)load("glTexCoordP3uiv");
	glad_glTexCoordP4ui = (PFNGLTEXCOORDP4UIPROC)load("glTexCoordP4ui");
	glad_glTexCoordP4uiv = (PFNGLTEXCOORDP4UIVPROC)load("glTexCoordP4uiv");
	glad_glMultiTexCoordP1ui = (PFNGLMULTITEXCOORDP1UIPROC)load("glMultiTexCoordP1ui");
	glad_glMultiTexCoordP1uiv = (PFNGLMULTITEXCOORDP1UIVPROC)load("glMultiTexCoordP1uiv");
	glad_glMultiTexCoordP2ui = (PFNGLMULTITEXCOORDP2UIPROC)load("glMultiTexCoordP2ui");
	glad_glMultiTexCoordP2uiv = (PFNGLMULTITEXCOORDP2UIVPROC)load("glMultiTexCoordP2uiv");
	glad_glMultiTexCoordP3ui = (PFNGLMULTITEXCOORDP3UIPROC)load("glMultiTexCoordP3ui");
	glad_glMultiTexCoordP3uiv = (PFNGLMULTITEXCOORDP3UIVPROC)load("glMultiTexCoordP3uiv");
	glad_glMultiTexCoordP4ui = (PFNGLMULTITEXCOORDP4UIPROC)load("glMultiTexCoordP4ui");
	glad_glMultiTexCoordP4uiv = (PFNGLMULTITEXCOORDP4UIVPROC)load("glMultiTexCoordP4uiv");
	glad_glNormalP3ui = (PFNGLNORMALP3UIPROC)load("glNormalP3ui");
	glad_glNormalP3uiv = (PFNGLNORMALP3UIVPROC)load("glNormalP3uiv");
	glad_glColorP3ui = (PFNGLCOLORP3UIPROC)load("glColorP3ui");
	glad_glColorP3uiv = (PFNGLCOLORP3UIVPROC)load("glColorP3uiv");
	glad_glColorP4ui = (PFNGLCOLORP4UIPROC)load("glColorP4ui");
	glad_glColorP4uiv = (PFNGLCOLORP4UIVPROC)load("glColorP4uiv");
	glad_glSecondaryColorP3ui = (PFNGLSECONDARYCOLORP3UIPROC)load("glSecondaryColorP3ui");
	glad_glSecondaryColorP3uiv = (PFNGLSECONDARYCOLORP3UIVPROC)load("glSecondaryColorP3uiv");
}
static void load_GL_VERSION_4_0(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_0) return;
	glad_glMinSampleShading = (PFNGLMINSAMPLESHADINGPROC)load("glMinSampleShading");
	glad_glBlendEquationi = (PFNGLBLENDEQUATIONIPROC)load("glBlendEquationi");
	glad_glBlendEquationSeparatei = (PFNGLBLENDEQUATIONSEPARATEIPROC)load("glBlendEquationSeparatei");
	glad_glBlendFunci = (PFNGLBLENDFUNCIPROC)load("glBlendFunci");
	glad_glBlendFuncSeparatei = (PFNGLBLENDFUNCSEPARATEIPROC)load("glBlendFuncSeparatei");
	glad_glDrawArraysIndirect = (PFNGLDRAWARRAYSINDIRECTPROC)load("glDrawArraysIndirect");
	glad_glDrawElementsIndirect = (PFNGLDRAWELEMENTSINDIRECTPROC)load("glDrawElementsIndirect");
	glad_glUniform1d = (PFNGLUNIFORM1DPROC)load("glUniform1d");
	glad_glUniform2d = (PFNGLUNIFORM2DPROC)load("glUniform2d");
	glad_glUniform3d = (PFNGLUNIFORM3DPROC)load("glUniform3d");
	glad_glUniform4d = (PFNGLUNIFORM4DPROC)load("glUniform4d");
	glad_glUniform1dv = (PFNGLUNIFORM1DVPROC)load("glUniform1dv");
	glad_glUniform2dv = (PFNGLUNIFORM2DVPROC)load("glUniform2dv");
	glad_glUniform3dv = (PFNGLUNIFORM3DVPROC)load("glUniform3dv");
	glad_glUniform4dv = (PFNGLUNIFORM4DVPROC)load("glUniform4dv");
	glad_glUniformMatrix2dv = (PFNGLUNIFORMMATRIX2DVPROC)load("glUniformMatrix2dv");
	glad_glUniformMatrix3dv = (PFNGLUNIFORMMATRIX3DVPROC)load("glUniformMatrix3dv");
	glad_glUniformMatrix4dv = (PFNGLUNIFORMMATRIX4DVPROC)load("glUniformMatrix4dv");
	glad_glUniformMatrix2x3dv = (PFNGLUNIFORMMATRIX2X3DVPROC)load("glUniformMatrix2x3dv");
	glad_glUniformMatrix2x4dv = (PFNGLUNIFORMMATRIX2X4DVPROC)load("glUniformMatrix2x4dv");
	glad_glUniformMatrix3x2dv = (PFNGLUNIFORMMATRIX3X2DVPROC)load("glUniformMatrix3x2dv");
	glad_glUniformMatrix3x4dv = (PFNGLUNIFORMMATRIX3X4DVPROC)load("glUniformMatrix3x4dv");
	glad_glUniformMatrix4x2dv = (PFNGLUNIFORMMATRIX4X2DVPROC)load("glUniformMatrix4x2dv");
	glad_glUniformMatrix4x3dv = (PFNGLUNIFORMMATRIX4X3DVPROC)load("glUniformMatrix4x3dv");
	glad_glGetUniformdv = (PFNGLGETUNIFORMDVPROC)load("glGetUniformdv");
	glad_glGetSubroutineUniformLocation = (PFNGLGETSUBROUTINEUNIFORMLOCATIONPROC)load("glGetSubroutineUniformLocation");
	glad_glGetSubroutineIndex = (PFNGLGETSUBROUTINEINDEXPROC)load("glGetSubroutineIndex");
	glad_glGetActiveSubroutineUniformiv = (PFNGLGETACTIVESUBROUTINEUNIFORMIVPROC)load("glGetActiveSubroutineUniformiv");
	glad_glGetActiveSubroutineUniformName = (PFNGLGETACTIVESUBROUTINEUNIFORMNAMEPROC)load("glGetActiveSubroutineUniformName");
	glad_glGetActiveSubroutineName = (PFNGLGETACTIVESUBROUTINENAMEPROC)load("glGetActiveSubroutineName");
	glad_glUniformSubroutinesuiv = (PFNGLUNIFORMSUBROUTINESUIVPROC)load("glUniformSubroutinesuiv");
	glad_glGetUniformSubroutineuiv = (PFNGLGETUNIFORMSUBROUTINEUIVPROC)load("glGetUniformSubroutineuiv");
	glad_glGetProgramStageiv = (PFNGLGETPROGRAMSTAGEIVPROC)load("glGetProgramStageiv");
	glad_glPatchParameteri = (PFNGLPATCHPARAMETERIPROC)load("glPatchParameteri");
	glad_glPatchParameterfv = (PFNGLPATCHPARAMETERFVPROC)load("glPatchParameterfv");
	glad_glBindTransformFeedback = (PFNGLBINDTRANSFORMFEEDBACKPROC)load("glBindTransformFeedback");
	glad_glDeleteTransformFeedbacks = (PFNGLDELETETRANSFORMFEEDBACKSPROC)load("glDeleteTransformFeedbacks");
	glad_glGenTransformFeedbacks = (PFNGLGENTRANSFORMFEEDBACKSPROC)load("glGenTransformFeedbacks");
	glad_glIsTransformFeedback = (PFNGLISTRANSFORMFEEDBACKPROC)load("glIsTransformFeedback");
	glad_glPauseTransformFeedback = (PFNGLPAUSETRANSFORMFEEDBACKPROC)load("glPauseTransformFeedback");
	glad_glResumeTransformFeedback = (PFNGLRESUMETRANSFORMFEEDBACKPROC)load("glResumeTransformFeedback");
	glad_glDrawTransformFeedback = (PFNGLDRAWTRANSFORMFEEDBACKPROC)load("glDrawTransformFeedback");
	glad_glDrawTransformFeedbackStream = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMPROC)load("glDrawTransformFeedbackStream");
	glad_glBeginQueryIndexed = (PFNGLBEGINQUERYINDEXEDPROC)load("glBeginQueryIndexed");
	glad_glEndQueryIndexed = (PFNGLENDQUERYINDEXEDPROC)load("glEndQueryIndexed");
	glad_glGetQueryIndexediv = (PFNGLGETQUERYINDEXEDIVPROC)load("glGetQueryIndexediv");
}
static void load_GL_VERSION_4_1(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_1) return;
	glad_glReleaseShaderCompiler = (PFNGLRELEASESHADERCOMPILERPROC)load("glReleaseShaderCompiler");
	glad_glShaderBinary = (PFNGLSHADERBINARYPROC)load("glShaderBinary");
	glad_glGetShaderPrecisionFormat = (PFNGLGETSHADERPRECISIONFORMATPROC)load("glGetShaderPrecisionFormat");
	glad_glDepthRangef = (PFNGLDEPTHRANGEFPROC)load("glDepthRangef");
	glad_glClearDepthf = (PFNGLCLEARDEPTHFPROC)load("glClearDepthf");
	glad_glGetProgramBinary = (PFNGLGETPROGRAMBINARYPROC)load("glGetProgramBinary");
	glad_glProgramBinary = (PFNGLPROGRAMBINARYPROC)load("glProgramBinary");
	glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)load("glProgramParameteri");
	glad_glUseProgramStages = (PFNGLUSEPROGRAMSTAGESPROC)load("glUseProgramStages");
	glad_glActiveShaderProgram = (PFNGLACTIVESHADERPROGRAMPROC)load("glActiveShaderProgram");
	glad_glCreateShaderProgramv = (PFNGLCREATESHADERPROGRAMVPROC)load("glCreateShaderProgramv");
	glad_glBindProgramPipeline = (PFNGLBINDPROGRAMPIPELINEPROC)load("glBindProgramPipeline");
	glad_glDeleteProgramPipelines = (PFNGLDELETEPROGRAMPIPELINESPROC)load("glDeleteProgramPipelines");
	glad_glGenProgramPipelines = (PFNGLGENPROGRAMPIPELINESPROC)load("glGenProgramPipelines");
	glad_glIsProgramPipeline = (PFNGLISPROGRAMPIPELINEPROC)load("glIsProgramPipeline");
	glad_glGetProgramPipelineiv = (PFNGLGETPROGRAMPIPELINEIVPROC)load("glGetProgramPipelineiv");
	glad_glProgramParameteri = (PFNGLPROGRAMPARAMETERIPROC)load("glProgramParameteri");
	glad_glProgramUniform1i = (PFNGLPROGRAMUNIFORM1IPROC)load("glProgramUniform1i");
	glad_glProgramUniform1iv = (PFNGLPROGRAMUNIFORM1IVPROC)load("glProgramUniform1iv");
	glad_glProgramUniform1f = (PFNGLPROGRAMUNIFORM1FPROC)load("glProgramUniform1f");
	glad_glProgramUniform1fv = (PFNGLPROGRAMUNIFORM1FVPROC)load("glProgramUniform1fv");
	glad_glProgramUniform1d = (PFNGLPROGRAMUNIFORM1DPROC)load("glProgramUniform1d");
	glad_glProgramUniform1dv = (PFNGLPROGRAMUNIFORM1DVPROC)load("glProgramUniform1dv");
	glad_glProgramUniform1ui = (PFNGLPROGRAMUNIFORM1UIPROC)load("glProgramUniform1ui");
	glad_glProgramUniform1uiv = (PFNGLPROGRAMUNIFORM1UIVPROC)load("glProgramUniform1uiv");
	glad_glProgramUniform2i = (PFNGLPROGRAMUNIFORM2IPROC)load("glProgramUniform2i");
	glad_glProgramUniform2iv = (PFNGLPROGRAMUNIFORM2IVPROC)load("glProgramUniform2iv");
	glad_glProgramUniform2f = (PFNGLPROGRAMUNIFORM2FPROC)load("glProgramUniform2f");
	glad_glProgramUniform2fv = (PFNGLPROGRAMUNIFORM2FVPROC)load("glProgramUniform2fv");
	glad_glProgramUniform2d = (PFNGLPROGRAMUNIFORM2DPROC)load("glProgramUniform2d");
	glad_glProgramUniform2dv = (PFNGLPROGRAMUNIFORM2DVPROC)load("glProgramUniform2dv");
	glad_glProgramUniform2ui = (PFNGLPROGRAMUNIFORM2UIPROC)load("glProgramUniform2ui");
	glad_glProgramUniform2uiv = (PFNGLPROGRAMUNIFORM2UIVPROC)load("glProgramUniform2uiv");
	glad_glProgramUniform3i = (PFNGLPROGRAMUNIFORM3IPROC)load("glProgramUniform3i");
	glad_glProgramUniform3iv = (PFNGLPROGRAMUNIFORM3IVPROC)load("glProgramUniform3iv");
	glad_glProgramUniform3f = (PFNGLPROGRAMUNIFORM3FPROC)load("glProgramUniform3f");
	glad_glProgramUniform3fv = (PFNGLPROGRAMUNIFORM3FVPROC)load("glProgramUniform3fv");
	glad_glProgramUniform3d = (PFNGLPROGRAMUNIFORM3DPROC)load("glProgramUniform3d");
	glad_glProgramUniform3dv = (PFNGLPROGRAMUNIFORM3DVPROC)load("glProgramUniform3dv");
	glad_glProgramUniform3ui = (PFNGLPROGRAMUNIFORM3UIPROC)load("glProgramUniform3ui");
	glad_glProgramUniform3uiv = (PFNGLPROGRAMUNIFORM3UIVPROC)load("glProgramUniform3uiv");
	glad_glProgramUniform4i = (PFNGLPROGRAMUNIFORM4IPROC)load("glProgramUniform4i");
	glad_glProgramUniform4iv = (PFNGLPROGRAMUNIFORM4IVPROC)load("glProgramUniform4iv");
	glad_glProgramUniform4f = (PFNGLPROGRAMUNIFORM4FPROC)load("glProgramUniform4f");
	glad_glProgramUniform4fv = (PFNGLPROGRAMUNIFORM4FVPROC)load("glProgramUniform4fv");
	glad_glProgramUniform4d = (PFNGLPROGRAMUNIFORM4DPROC)load("glProgramUniform4d");
	glad_glProgramUniform4dv = (PFNGLPROGRAMUNIFORM4DVPROC)load("glProgramUniform4dv");
	glad_glProgramUniform4ui = (PFNGLPROGRAMUNIFORM4UIPROC)load("glProgramUniform4ui");
	glad_glProgramUniform4uiv = (PFNGLPROGRAMUNIFORM4UIVPROC)load("glProgramUniform4uiv");
	glad_glProgramUniformMatrix2fv = (PFNGLPROGRAMUNIFORMMATRIX2FVPROC)load("glProgramUniformMatrix2fv");
	glad_glProgramUniformMatrix3fv = (PFNGLPROGRAMUNIFORMMATRIX3FVPROC)load("glProgramUniformMatrix3fv");
	glad_glProgramUniformMatrix4fv = (PFNGLPROGRAMUNIFORMMATRIX4FVPROC)load("glProgramUniformMatrix4fv");
	glad_glProgramUniformMatrix2dv = (PFNGLPROGRAMUNIFORMMATRIX2DVPROC)load("glProgramUniformMatrix2dv");
	glad_glProgramUniformMatrix3dv = (PFNGLPROGRAMUNIFORMMATRIX3DVPROC)load("glProgramUniformMatrix3dv");
	glad_glProgramUniformMatrix4dv = (PFNGLPROGRAMUNIFORMMATRIX4DVPROC)load("glProgramUniformMatrix4dv");
	glad_glProgramUniformMatrix2x3fv = (PFNGLPROGRAMUNIFORMMATRIX2X3FVPROC)load("glProgramUniformMatrix2x3fv");
	glad_glProgramUniformMatrix3x2fv = (PFNGLPROGRAMUNIFORMMATRIX3X2FVPROC)load("glProgramUniformMatrix3x2fv");
	glad_glProgramUniformMatrix2x4fv = (PFNGLPROGRAMUNIFORMMATRIX2X4FVPROC)load("glProgramUniformMatrix2x4fv");
	glad_glProgramUniformMatrix4x2fv = (PFNGLPROGRAMUNIFORMMATRIX4X2FVPROC)load("glProgramUniformMatrix4x2fv");
	glad_glProgramUniformMatrix3x4fv = (PFNGLPROGRAMUNIFORMMATRIX3X4FVPROC)load("glProgramUniformMatrix3x4fv");
	glad_glProgramUniformMatrix4x3fv = (PFNGLPROGRAMUNIFORMMATRIX4X3FVPROC)load("glProgramUniformMatrix4x3fv");
	glad_glProgramUniformMatrix2x3dv = (PFNGLPROGRAMUNIFORMMATRIX2X3DVPROC)load("glProgramUniformMatrix2x3dv");
	glad_glProgramUniformMatrix3x2dv = (PFNGLPROGRAMUNIFORMMATRIX3X2DVPROC)load("glProgramUniformMatrix3x2dv");
	glad_glProgramUniformMatrix2x4dv = (PFNGLPROGRAMUNIFORMMATRIX2X4DVPROC)load("glProgramUniformMatrix2x4dv");
	glad_glProgramUniformMatrix4x2dv = (PFNGLPROGRAMUNIFORMMATRIX4X2DVPROC)load("glProgramUniformMatrix4x2dv");
	glad_glProgramUniformMatrix3x4dv = (PFNGLPROGRAMUNIFORMMATRIX3X4DVPROC)load("glProgramUniformMatrix3x4dv");
	glad_glProgramUniformMatrix4x3dv = (PFNGLPROGRAMUNIFORMMATRIX4X3DVPROC)load("glProgramUniformMatrix4x3dv");
	glad_glValidateProgramPipeline = (PFNGLVALIDATEPROGRAMPIPELINEPROC)load("glValidateProgramPipeline");
	glad_glGetProgramPipelineInfoLog = (PFNGLGETPROGRAMPIPELINEINFOLOGPROC)load("glGetProgramPipelineInfoLog");
	glad_glVertexAttribL1d = (PFNGLVERTEXATTRIBL1DPROC)load("glVertexAttribL1d");
	glad_glVertexAttribL2d = (PFNGLVERTEXATTRIBL2DPROC)load("glVertexAttribL2d");
	glad_glVertexAttribL3d = (PFNGLVERTEXATTRIBL3DPROC)load("glVertexAttribL3d");
	glad_glVertexAttribL4d = (PFNGLVERTEXATTRIBL4DPROC)load("glVertexAttribL4d");
	glad_glVertexAttribL1dv = (PFNGLVERTEXATTRIBL1DVPROC)load("glVertexAttribL1dv");
	glad_glVertexAttribL2dv = (PFNGLVERTEXATTRIBL2DVPROC)load("glVertexAttribL2dv");
	glad_glVertexAttribL3dv = (PFNGLVERTEXATTRIBL3DVPROC)load("glVertexAttribL3dv");
	glad_glVertexAttribL4dv = (PFNGLVERTEXATTRIBL4DVPROC)load("glVertexAttribL4dv");
	glad_glVertexAttribLPointer = (PFNGLVERTEXATTRIBLPOINTERPROC)load("glVertexAttribLPointer");
	glad_glGetVertexAttribLdv = (PFNGLGETVERTEXATTRIBLDVPROC)load("glGetVertexAttribLdv");
	glad_glViewportArrayv = (PFNGLVIEWPORTARRAYVPROC)load("glViewportArrayv");
	glad_glViewportIndexedf = (PFNGLVIEWPORTINDEXEDFPROC)load("glViewportIndexedf");
	glad_glViewportIndexedfv = (PFNGLVIEWPORTINDEXEDFVPROC)load("glViewportIndexedfv");
	glad_glScissorArrayv = (PFNGLSCISSORARRAYVPROC)load("glScissorArrayv");
	glad_glScissorIndexed = (PFNGLSCISSORINDEXEDPROC)load("glScissorIndexed");
	glad_glScissorIndexedv = (PFNGLSCISSORINDEXEDVPROC)load("glScissorIndexedv");
	glad_glDepthRangeArrayv = (PFNGLDEPTHRANGEARRAYVPROC)load("glDepthRangeArrayv");
	glad_glDepthRangeIndexed = (PFNGLDEPTHRANGEINDEXEDPROC)load("glDepthRangeIndexed");
	glad_glGetFloati_v = (PFNGLGETFLOATI_VPROC)load("glGetFloati_v");
	glad_glGetDoublei_v = (PFNGLGETDOUBLEI_VPROC)load("glGetDoublei_v");
}
static void load_GL_VERSION_4_2(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_2) return;
	glad_glDrawArraysInstancedBaseInstance = (PFNGLDRAWARRAYSINSTANCEDBASEINSTANCEPROC)load("glDrawArraysInstancedBaseInstance");
	glad_glDrawElementsInstancedBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEINSTANCEPROC)load("glDrawElementsInstancedBaseInstance");
	glad_glDrawElementsInstancedBaseVertexBaseInstance = (PFNGLDRAWELEMENTSINSTANCEDBASEVERTEXBASEINSTANCEPROC)load("glDrawElementsInstancedBaseVertexBaseInstance");
	glad_glGetInternalformativ = (PFNGLGETINTERNALFORMATIVPROC)load("glGetInternalformativ");
	glad_glGetActiveAtomicCounterBufferiv = (PFNGLGETACTIVEATOMICCOUNTERBUFFERIVPROC)load("glGetActiveAtomicCounterBufferiv");
	glad_glBindImageTexture = (PFNGLBINDIMAGETEXTUREPROC)load("glBindImageTexture");
	glad_glMemoryBarrier = (PFNGLMEMORYBARRIERPROC)load("glMemoryBarrier");
	glad_glTexStorage1D = (PFNGLTEXSTORAGE1DPROC)load("glTexStorage1D");
	glad_glTexStorage2D = (PFNGLTEXSTORAGE2DPROC)load("glTexStorage2D");
	glad_glTexStorage3D = (PFNGLTEXSTORAGE3DPROC)load("glTexStorage3D");
	glad_glDrawTransformFeedbackInstanced = (PFNGLDRAWTRANSFORMFEEDBACKINSTANCEDPROC)load("glDrawTransformFeedbackInstanced");
	glad_glDrawTransformFeedbackStreamInstanced = (PFNGLDRAWTRANSFORMFEEDBACKSTREAMINSTANCEDPROC)load("glDrawTransformFeedbackStreamInstanced");
}
static void load_GL_VERSION_4_3(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_3) return;
	glad_glClearBufferData = (PFNGLCLEARBUFFERDATAPROC)load("glClearBufferData");
	glad_glClearBufferSubData = (PFNGLCLEARBUFFERSUBDATAPROC)load("glClearBufferSubData");
	glad_glDispatchCompute = (PFNGLDISPATCHCOMPUTEPROC)load("glDispatchCompute");
	glad_glDispatchComputeIndirect = (PFNGLDISPATCHCOMPUTEINDIRECTPROC)load("glDispatchComputeIndirect");
	glad_glCopyImageSubData = (PFNGLCOPYIMAGESUBDATAPROC)load("glCopyImageSubData");
	glad_glFramebufferParameteri = (PFNGLFRAMEBUFFERPARAMETERIPROC)load("glFramebufferParameteri");
	glad_glGetFramebufferParameteriv = (PFNGLGETFRAMEBUFFERPARAMETERIVPROC)load("glGetFramebufferParameteriv");
	glad_glGetInternalformati64v = (PFNGLGETINTERNALFORMATI64VPROC)load("glGetInternalformati64v");
	glad_glInvalidateTexSubImage = (PFNGLINVALIDATETEXSUBIMAGEPROC)load("glInvalidateTexSubImage");
	glad_glInvalidateTexImage = (PFNGLINVALIDATETEXIMAGEPROC)load("glInvalidateTexImage");
	glad_glInvalidateBufferSubData = (PFNGLINVALIDATEBUFFERSUBDATAPROC)load("glInvalidateBufferSubData");
	glad_glInvalidateBufferData = (PFNGLINVALIDATEBUFFERDATAPROC)load("glInvalidateBufferData");
	glad_glInvalidateFramebuffer = (PFNGLINVALIDATEFRAMEBUFFERPROC)load("glInvalidateFramebuffer");
	glad_glInvalidateSubFramebuffer = (PFNGLINVALIDATESUBFRAMEBUFFERPROC)load("glInvalidateSubFramebuffer");
	glad_glMultiDrawArraysIndirect = (PFNGLMULTIDRAWARRAYSINDIRECTPROC)load("glMultiDrawArraysIndirect");
	glad_glMultiDrawElementsIndirect = (PFNGLMULTIDRAWELEMENTSINDIRECTPROC)load("glMultiDrawElementsIndirect");
	glad_glGetProgramInterfaceiv = (PFNGLGETPROGRAMINTERFACEIVPROC)load("glGetProgramInterfaceiv");
	glad_glGetProgramResourceIndex = (PFNGLGETPROGRAMRESOURCEINDEXPROC)load("glGetProgramResourceIndex");
	glad_glGetProgramResourceName = (PFNGLGETPROGRAMRESOURCENAMEPROC)load("glGetProgramResourceName");
	glad_glGetProgramResourceiv = (PFNGLGETPROGRAMRESOURCEIVPROC)load("glGetProgramResourceiv");
	glad_glGetProgramResourceLocation = (PFNGLGETPROGRAMRESOURCELOCATIONPROC)load("glGetProgramResourceLocation");
	glad_glGetProgramResourceLocationIndex = (PFNGLGETPROGRAMRESOURCELOCATIONINDEXPROC)load("glGetProgramResourceLocationIndex");
	glad_glShaderStorageBlockBinding = (PFNGLSHADERSTORAGEBLOCKBINDINGPROC)load("glShaderStorageBlockBinding");
	glad_glTexBufferRange = (PFNGLTEXBUFFERRANGEPROC)load("glTexBufferRange");
	glad_glTexStorage2DMultisample = (PFNGLTEXSTORAGE2DMULTISAMPLEPROC)load("glTexStorage2DMultisample");
	glad_glTexStorage3DMultisample = (PFNGLTEXSTORAGE3DMULTISAMPLEPROC)load("glTexStorage3DMultisample");
	glad_glTextureView = (PFNGLTEXTUREVIEWPROC)load("glTextureView");
	glad_glBindVertexBuffer = (PFNGLBINDVERTEXBUFFERPROC)load("glBindVertexBuffer");
	glad_glVertexAttribFormat = (PFNGLVERTEXATTRIBFORMATPROC)load("glVertexAttribFormat");
	glad_glVertexAttribIFormat = (PFNGLVERTEXATTRIBIFORMATPROC)load("glVertexAttribIFormat");
	glad_glVertexAttribLFormat = (PFNGLVERTEXATTRIBLFORMATPROC)load("glVertexAttribLFormat");
	glad_glVertexAttribBinding = (PFNGLVERTEXATTRIBBINDINGPROC)load("glVertexAttribBinding");
	glad_glVertexBindingDivisor = (PFNGLVERTEXBINDINGDIVISORPROC)load("glVertexBindingDivisor");
	glad_glDebugMessageControl = (PFNGLDEBUGMESSAGECONTROLPROC)load("glDebugMessageControl");
	glad_glDebugMessageInsert = (PFNGLDEBUGMESSAGEINSERTPROC)load("glDebugMessageInsert");
	glad_glDebugMessageCallback = (PFNGLDEBUGMESSAGECALLBACKPROC)load("glDebugMessageCallback");
	glad_glGetDebugMessageLog = (PFNGLGETDEBUGMESSAGELOGPROC)load("glGetDebugMessageLog");
	glad_glPushDebugGroup = (PFNGLPUSHDEBUGGROUPPROC)load("glPushDebugGroup");
	glad_glPopDebugGroup = (PFNGLPOPDEBUGGROUPPROC)load("glPopDebugGroup");
	glad_glObjectLabel = (PFNGLOBJECTLABELPROC)load("glObjectLabel");
	glad_glGetObjectLabel = (PFNGLGETOBJECTLABELPROC)load("glGetObjectLabel");
	glad_glObjectPtrLabel = (PFNGLOBJECTPTRLABELPROC)load("glObjectPtrLabel");
	glad_glGetObjectPtrLabel = (PFNGLGETOBJECTPTRLABELPROC)load("glGetObjectPtrLabel");
	glad_glGetPointerv = (PFNGLGETPOINTERVPROC)load("glGetPointerv");
}
static void load_GL_VERSION_4_4(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_4) return;
	glad_glBufferStorage = (PFNGLBUFFERSTORAGEPROC)load("glBufferStorage");
	glad_glClearTexImage = (PFNGLCLEARTEXIMAGEPROC)load("glClearTexImage");
	glad_glClearTexSubImage = (PFNGLCLEARTEXSUBIMAGEPROC)load("glClearTexSubImage");
	glad_glBindBuffersBase = (PFNGLBINDBUFFERSBASEPROC)load("glBindBuffersBase");
	glad_glBindBuffersRange = (PFNGLBINDBUFFERSRANGEPROC)load("glBindBuffersRange");
	glad_glBindTextures = (PFNGLBINDTEXTURESPROC)load("glBindTextures");
	glad_glBindSamplers = (PFNGLBINDSAMPLERSPROC)load("glBindSamplers");
	glad_glBindImageTextures = (PFNGLBINDIMAGETEXTURESPROC)load("glBindImageTextures");
	glad_glBindVertexBuffers = (PFNGLBINDVERTEXBUFFERSPROC)load("glBindVertexBuffers");
}
static void load_GL_VERSION_4_5(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_5) return;
	glad_glClipControl = (PFNGLCLIPCONTROLPROC)load("glClipControl");
	glad_glCreateTransformFeedbacks = (PFNGLCREATETRANSFORMFEEDBACKSPROC)load("glCreateTransformFeedbacks");
	glad_glTransformFeedbackBufferBase = (PFNGLTRANSFORMFEEDBACKBUFFERBASEPROC)load("glTransformFeedbackBufferBase");
	glad_glTransformFeedbackBufferRange = (PFNGLTRANSFORMFEEDBACKBUFFERRANGEPROC)load("glTransformFeedbackBufferRange");
	glad_glGetTransformFeedbackiv = (PFNGLGETTRANSFORMFEEDBACKIVPROC)load("glGetTransformFeedbackiv");
	glad_glGetTransformFeedbacki_v = (PFNGLGETTRANSFORMFEEDBACKI_VPROC)load("glGetTransformFeedbacki_v");
	glad_glGetTransformFeedbacki64_v = (PFNGLGETTRANSFORMFEEDBACKI64_VPROC)load("glGetTransformFeedbacki64_v");
	glad_glCreateBuffers = (PFNGLCREATEBUFFERSPROC)load("glCreateBuffers");
	glad_glNamedBufferStorage = (PFNGLNAMEDBUFFERSTORAGEPROC)load("glNamedBufferStorage");
	glad_glNamedBufferData = (PFNGLNAMEDBUFFERDATAPROC)load("glNamedBufferData");
	glad_glNamedBufferSubData = (PFNGLNAMEDBUFFERSUBDATAPROC)load("glNamedBufferSubData");
	glad_glCopyNamedBufferSubData = (PFNGLCOPYNAMEDBUFFERSUBDATAPROC)load("glCopyNamedBufferSubData");
	glad_glClearNamedBufferData = (PFNGLCLEARNAMEDBUFFERDATAPROC)load("glClearNamedBufferData");
	glad_glClearNamedBufferSubData = (PFNGLCLEARNAMEDBUFFERSUBDATAPROC)load("glClearNamedBufferSubData");
	glad_glMapNamedBuffer = (PFNGLMAPNAMEDBUFFERPROC)load("glMapNamedBuffer");
	glad_glMapNamedBufferRange = (PFNGLMAPNAMEDBUFFERRANGEPROC)load("glMapNamedBufferRange");
	glad_glUnmapNamedBuffer = (PFNGLUNMAPNAMEDBUFFERPROC)load("glUnmapNamedBuffer");
	glad_glFlushMappedNamedBufferRange = (PFNGLFLUSHMAPPEDNAMEDBUFFERRANGEPROC)load("glFlushMappedNamedBufferRange");
	glad_glGetNamedBufferParameteriv = (PFNGLGETNAMEDBUFFERPARAMETERIVPROC)load("glGetNamedBufferParameteriv");
	glad_glGetNamedBufferParameteri64v = (PFNGLGETNAMEDBUFFERPARAMETERI64VPROC)load("glGetNamedBufferParameteri64v");
	glad_glGetNamedBufferPointerv = (PFNGLGETNAMEDBUFFERPOINTERVPROC)load("glGetNamedBufferPointerv");
	glad_glGetNamedBufferSubData = (PFNGLGETNAMEDBUFFERSUBDATAPROC)load("glGetNamedBufferSubData");
	glad_glCreateFramebuffers = (PFNGLCREATEFRAMEBUFFERSPROC)load("glCreateFramebuffers");
	glad_glNamedFramebufferRenderbuffer = (PFNGLNAMEDFRAMEBUFFERRENDERBUFFERPROC)load("glNamedFramebufferRenderbuffer");
	glad_glNamedFramebufferParameteri = (PFNGLNAMEDFRAMEBUFFERPARAMETERIPROC)load("glNamedFramebufferParameteri");
	glad_glNamedFramebufferTexture = (PFNGLNAMEDFRAMEBUFFERTEXTUREPROC)load("glNamedFramebufferTexture");
	glad_glNamedFramebufferTextureLayer = (PFNGLNAMEDFRAMEBUFFERTEXTURELAYERPROC)load("glNamedFramebufferTextureLayer");
	glad_glNamedFramebufferDrawBuffer = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERPROC)load("glNamedFramebufferDrawBuffer");
	glad_glNamedFramebufferDrawBuffers = (PFNGLNAMEDFRAMEBUFFERDRAWBUFFERSPROC)load("glNamedFramebufferDrawBuffers");
	glad_glNamedFramebufferReadBuffer = (PFNGLNAMEDFRAMEBUFFERREADBUFFERPROC)load("glNamedFramebufferReadBuffer");
	glad_glInvalidateNamedFramebufferData = (PFNGLINVALIDATENAMEDFRAMEBUFFERDATAPROC)load("glInvalidateNamedFramebufferData");
	glad_glInvalidateNamedFramebufferSubData = (PFNGLINVALIDATENAMEDFRAMEBUFFERSUBDATAPROC)load("glInvalidateNamedFramebufferSubData");
	glad_glClearNamedFramebufferiv = (PFNGLCLEARNAMEDFRAMEBUFFERIVPROC)load("glClearNamedFramebufferiv");
	glad_glClearNamedFramebufferuiv = (PFNGLCLEARNAMEDFRAMEBUFFERUIVPROC)load("glClearNamedFramebufferuiv");
	glad_glClearNamedFramebufferfv = (PFNGLCLEARNAMEDFRAMEBUFFERFVPROC)load("glClearNamedFramebufferfv");
	glad_glClearNamedFramebufferfi = (PFNGLCLEARNAMEDFRAMEBUFFERFIPROC)load("glClearNamedFramebufferfi");
	glad_glBlitNamedFramebuffer = (PFNGLBLITNAMEDFRAMEBUFFERPROC)load("glBlitNamedFramebuffer");
	glad_glCheckNamedFramebufferStatus = (PFNGLCHECKNAMEDFRAMEBUFFERSTATUSPROC)load("glCheckNamedFramebufferStatus");
	glad_glGetNamedFramebufferParameteriv = (PFNGLGETNAMEDFRAMEBUFFERPARAMETERIVPROC)load("glGetNamedFramebufferParameteriv");
	glad_glGetNamedFramebufferAttachmentParameteriv = (PFNGLGETNAMEDFRAMEBUFFERATTACHMENTPARAMETERIVPROC)load("glGetNamedFramebufferAttachmentParameteriv");
	glad_glCreateRenderbuffers = (PFNGLCREATERENDERBUFFERSPROC)load("glCreateRenderbuffers");
	glad_glNamedRenderbufferStorage = (PFNGLNAMEDRENDERBUFFERSTORAGEPROC)load("glNamedRenderbufferStorage");
	glad_glNamedRenderbufferStorageMultisample = (PFNGLNAMEDRENDERBUFFERSTORAGEMULTISAMPLEPROC)load("glNamedRenderbufferStorageMultisample");
	glad_glGetNamedRenderbufferParameteriv = (PFNGLGETNAMEDRENDERBUFFERPARAMETERIVPROC)load("glGetNamedRenderbufferParameteriv");
	glad_glCreateTextures = (PFNGLCREATETEXTURESPROC)load("glCreateTextures");
	glad_glTextureBuffer = (PFNGLTEXTUREBUFFERPROC)load("glTextureBuffer");
	glad_glTextureBufferRange = (PFNGLTEXTUREBUFFERRANGEPROC)load("glTextureBufferRange");
	glad_glTextureStorage1D = (PFNGLTEXTURESTORAGE1DPROC)load("glTextureStorage1D");
	glad_glTextureStorage2D = (PFNGLTEXTURESTORAGE2DPROC)load("glTextureStorage2D");
	glad_glTextureStorage3D = (PFNGLTEXTURESTORAGE3DPROC)load("glTextureStorage3D");
	glad_glTextureStorage2DMultisample = (PFNGLTEXTURESTORAGE2DMULTISAMPLEPROC)load("glTextureStorage2DMultisample");
	glad_glTextureStorage3DMultisample = (PFNGLTEXTURESTORAGE3DMULTISAMPLEPROC)load("glTextureStorage3DMultisample");
	glad_glTextureSubImage1D = (PFNGLTEXTURESUBIMAGE1DPROC)load("glTextureSubImage1D");
	glad_glTextureSubImage2D = (PFNGLTEXTURESUBIMAGE2DPROC)load("glTextureSubImage2D");
	glad_glTextureSubImage3D = (PFNGLTEXTURESUBIMAGE3DPROC)load("glTextureSubImage3D");
	glad_glCompressedTextureSubImage1D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE1DPROC)load("glCompressedTextureSubImage1D");
	glad_glCompressedTextureSubImage2D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE2DPROC)load("glCompressedTextureSubImage2D");
	glad_glCompressedTextureSubImage3D = (PFNGLCOMPRESSEDTEXTURESUBIMAGE3DPROC)load("glCompressedTextureSubImage3D");
	glad_glCopyTextureSubImage1D = (PFNGLCOPYTEXTURESUBIMAGE1DPROC)load("glCopyTextureSubImage1D");
	glad_glCopyTextureSubImage2D = (PFNGLCOPYTEXTURESUBIMAGE2DPROC)load("glCopyTextureSubImage2D");
	glad_glCopyTextureSubImage3D = (PFNGLCOPYTEXTURESUBIMAGE3DPROC)load("glCopyTextureSubImage3D");
	glad_glTextureParameterf = (PFNGLTEXTUREPARAMETERFPROC)load("glTextureParameterf");
	glad_glTextureParameterfv = (PFNGLTEXTUREPARAMETERFVPROC)load("glTextureParameterfv");
	glad_glTextureParameteri = (PFNGLTEXTUREPARAMETERIPROC)load("glTextureParameteri");
	glad_glTextureParameterIiv = (PFNGLTEXTUREPARAMETERIIVPROC)load("glTextureParameterIiv");
	glad_glTextureParameterIuiv = (PFNGLTEXTUREPARAMETERIUIVPROC)load("glTextureParameterIuiv");
	glad_glTextureParameteriv = (PFNGLTEXTUREPARAMETERIVPROC)load("glTextureParameteriv");
	glad_glGenerateTextureMipmap = (PFNGLGENERATETEXTUREMIPMAPPROC)load("glGenerateTextureMipmap");
	glad_glBindTextureUnit = (PFNGLBINDTEXTUREUNITPROC)load("glBindTextureUnit");
	glad_glGetTextureImage = (PFNGLGETTEXTUREIMAGEPROC)load("glGetTextureImage");
	glad_glGetCompressedTextureImage = (PFNGLGETCOMPRESSEDTEXTUREIMAGEPROC)load("glGetCompressedTextureImage");
	glad_glGetTextureLevelParameterfv = (PFNGLGETTEXTURELEVELPARAMETERFVPROC)load("glGetTextureLevelParameterfv");
	glad_glGetTextureLevelParameteriv = (PFNGLGETTEXTURELEVELPARAMETERIVPROC)load("glGetTextureLevelParameteriv");
	glad_glGetTextureParameterfv = (PFNGLGETTEXTUREPARAMETERFVPROC)load("glGetTextureParameterfv");
	glad_glGetTextureParameterIiv = (PFNGLGETTEXTUREPARAMETERIIVPROC)load("glGetTextureParameterIiv");
	glad_glGetTextureParameterIuiv = (PFNGLGETTEXTUREPARAMETERIUIVPROC)load("glGetTextureParameterIuiv");
	glad_glGetTextureParameteriv = (PFNGLGETTEXTUREPARAMETERIVPROC)load("glGetTextureParameteriv");
	glad_glCreateVertexArrays = (PFNGLCREATEVERTEXARRAYSPROC)load("glCreateVertexArrays");
	glad_glDisableVertexArrayAttrib = (PFNGLDISABLEVERTEXARRAYATTRIBPROC)load("glDisableVertexArrayAttrib");
	glad_glEnableVertexArrayAttrib = (PFNGLENABLEVERTEXARRAYATTRIBPROC)load("glEnableVertexArrayAttrib");
	glad_glVertexArrayElementBuffer = (PFNGLVERTEXARRAYELEMENTBUFFERPROC)load("glVertexArrayElementBuffer");
	glad_glVertexArrayVertexBuffer = (PFNGLVERTEXARRAYVERTEXBUFFERPROC)load("glVertexArrayVertexBuffer");
	glad_glVertexArrayVertexBuffers = (PFNGLVERTEXARRAYVERTEXBUFFERSPROC)load("glVertexArrayVertexBuffers");
	glad_glVertexArrayAttribBinding = (PFNGLVERTEXARRAYATTRIBBINDINGPROC)load("glVertexArrayAttribBinding");
	glad_glVertexArrayAttribFormat = (PFNGLVERTEXARRAYATTRIBFORMATPROC)load("glVertexArrayAttribFormat");
	glad_glVertexArrayAttribIFormat = (PFNGLVERTEXARRAYATTRIBIFORMATPROC)load("glVertexArrayAttribIFormat");
	glad_glVertexArrayAttribLFormat = (PFNGLVERTEXARRAYATTRIBLFORMATPROC)load("glVertexArrayAttribLFormat");
	glad_glVertexArrayBindingDivisor = (PFNGLVERTEXARRAYBINDINGDIVISORPROC)load("glVertexArrayBindingDivisor");
	glad_glGetVertexArrayiv = (PFNGLGETVERTEXARRAYIVPROC)load("glGetVertexArrayiv");
	glad_glGetVertexArrayIndexediv = (PFNGLGETVERTEXARRAYINDEXEDIVPROC)load("glGetVertexArrayIndexediv");
	glad_glGetVertexArrayIndexed64iv = (PFNGLGETVERTEXARRAYINDEXED64IVPROC)load("glGetVertexArrayIndexed64iv");
	glad_glCreateSamplers = (PFNGLCREATESAMPLERSPROC)load("glCreateSamplers");
	glad_glCreateProgramPipelines = (PFNGLCREATEPROGRAMPIPELINESPROC)load("glCreateProgramPipelines");
	glad_glCreateQueries = (PFNGLCREATEQUERIESPROC)load("glCreateQueries");
	glad_glGetQueryBufferObjecti64v = (PFNGLGETQUERYBUFFEROBJECTI64VPROC)load("glGetQueryBufferObjecti64v");
	glad_glGetQueryBufferObjectiv = (PFNGLGETQUERYBUFFEROBJECTIVPROC)load("glGetQueryBufferObjectiv");
	glad_glGetQueryBufferObjectui64v = (PFNGLGETQUERYBUFFEROBJECTUI64VPROC)load("glGetQueryBufferObjectui64v");
	glad_glGetQueryBufferObjectuiv = (PFNGLGETQUERYBUFFEROBJECTUIVPROC)load("glGetQueryBufferObjectuiv");
	glad_glMemoryBarrierByRegion = (PFNGLMEMORYBARRIERBYREGIONPROC)load("glMemoryBarrierByRegion");
	glad_glGetTextureSubImage = (PFNGLGETTEXTURESUBIMAGEPROC)load("glGetTextureSubImage");
	glad_glGetCompressedTextureSubImage = (PFNGLGETCOMPRESSEDTEXTURESUBIMAGEPROC)load("glGetCompressedTextureSubImage");
	glad_glGetGraphicsResetStatus = (PFNGLGETGRAPHICSRESETSTATUSPROC)load("glGetGraphicsResetStatus");
	glad_glGetnCompressedTexImage = (PFNGLGETNCOMPRESSEDTEXIMAGEPROC)load("glGetnCompressedTexImage");
	glad_glGetnTexImage = (PFNGLGETNTEXIMAGEPROC)load("glGetnTexImage");
	glad_glGetnUniformdv = (PFNGLGETNUNIFORMDVPROC)load("glGetnUniformdv");
	glad_glGetnUniformfv = (PFNGLGETNUNIFORMFVPROC)load("glGetnUniformfv");
	glad_glGetnUniformiv = (PFNGLGETNUNIFORMIVPROC)load("glGetnUniformiv");
	glad_glGetnUniformuiv = (PFNGLGETNUNIFORMUIVPROC)load("glGetnUniformuiv");
	glad_glReadnPixels = (PFNGLREADNPIXELSPROC)load("glReadnPixels");
	glad_glGetnMapdv = (PFNGLGETNMAPDVPROC)load("glGetnMapdv");
	glad_glGetnMapfv = (PFNGLGETNMAPFVPROC)load("glGetnMapfv");
	glad_glGetnMapiv = (PFNGLGETNMAPIVPROC)load("glGetnMapiv");
	glad_glGetnPixelMapfv = (PFNGLGETNPIXELMAPFVPROC)load("glGetnPixelMapfv");
	glad_glGetnPixelMapuiv = (PFNGLGETNPIXELMAPUIVPROC)load("glGetnPixelMapuiv");
	glad_glGetnPixelMapusv = (PFNGLGETNPIXELMAPUSVPROC)load("glGetnPixelMapusv");
	glad_glGetnPolygonStipple = (PFNGLGETNPOLYGONSTIPPLEPROC)load("glGetnPolygonStipple");
	glad_glGetnColorTable = (PFNGLGETNCOLORTABLEPROC)load("glGetnColorTable");
	glad_glGetnConvolutionFilter = (PFNGLGETNCONVOLUTIONFILTERPROC)load("glGetnConvolutionFilter");
	glad_glGetnSeparableFilter = (PFNGLGETNSEPARABLEFILTERPROC)load("glGetnSeparableFilter");
	glad_glGetnHistogram = (PFNGLGETNHISTOGRAMPROC)load("glGetnHistogram");
	glad_glGetnMinmax = (PFNGLGETNMINMAXPROC)load("glGetnMinmax");
	glad_glTextureBarrier = (PFNGLTEXTUREBARRIERPROC)load("glTextureBarrier");
}
static void load_GL_VERSION_4_6(GLADloadproc load) {
	if(!GLAD_GL_VERSION_4_6) return;
	glad_glSpecializeShader = (PFNGLSPECIALIZESHADERPROC)load("glSpecializeShader");
	glad_glMultiDrawArraysIndirectCount = (PFNGLMULTIDRAWARRAYSINDIRECTCOUNTPROC)load("glMultiDrawArraysIndirectCount");
	glad_glMultiDrawElementsIndirectCount = (PFNGLMULTIDRAWELEMENTSINDIRECTCOUNTPROC)load("glMultiDrawElementsIndirectCount");
	glad_glPolygonOffsetClamp = (PFNGLPOLYGONOFFSETCLAMPPROC)load("glPolygonOffsetClamp");
}
static int find_extensionsGL(void) {
	if (!get_exts()) return 0;
	(void)&has_ext;
	free_exts();
	return 1;
}

static void find_coreGL(void) {

    /* Thank you @elmindreda
     * https://github.com/elmindreda/greg/blob/master/templates/greg.c.in#L176
     * https://github.com/glfw/glfw/blob/master/src/context.c#L36
     */
    int i, major, minor;

    const char* version;
    const char* prefixes[] = {
        "OpenGL ES-CM ",
        "OpenGL ES-CL ",
        "OpenGL ES ",
        NULL
    };

    version = (const char*) glGetString(GL_VERSION);
    if (!version) return;

    for (i = 0;  prefixes[i];  i++) {
        const size_t length = strlen(prefixes[i]);
        if (strncmp(version, prefixes[i], length) == 0) {
            version += length;
            break;
        }
    }

/* PR #18 */
#ifdef _MSC_VER
    sscanf_s(version, "%d.%d", &major, &minor);
#else
    sscanf(version, "%d.%d", &major, &minor);
#endif

	GLVersion.major = major; GLVersion.minor = minor;
	max_loaded_major = major; max_loaded_minor = minor;
	GLAD_GL_VERSION_1_0 = (major == 1 && minor >= 0) || major > 1;
	GLAD_GL_VERSION_1_1 = (major == 1 && minor >= 1) || major > 1;
	GLAD_GL_VERSION_1_2 = (major == 1 && minor >= 2) || major > 1;
	GLAD_GL_VERSION_1_3 = (major == 1 && minor >= 3) || major > 1;
	GLAD_GL_VERSION_1_4 = (major == 1 && minor >= 4) || major > 1;
	GLAD_GL_VERSION_1_5 = (major == 1 && minor >= 5) || major > 1;
	GLAD_GL_VERSION_2_0 = (major == 2 && minor >= 0) || major > 2;
	GLAD_GL_VERSION_2_1 = (major == 2 && minor >= 1) || major > 2;
	GLAD_GL_VERSION_3_0 = (major == 3 && minor >= 0) || major > 3;
	GLAD_GL_VERSION_3_1 = (major == 3 && minor >= 1) || major > 3;
	GLAD_GL_VERSION_3_2 = (major == 3 && minor >= 2) || major > 3;
	GLAD_GL_VERSION_3_3 = (major == 3 && minor >= 3) || major > 3;
	GLAD_GL_VERSION_4_0 = (major == 4 && minor >= 0) || major > 4;
	GLAD_GL_VERSION_4_1 = (major == 4 && minor >= 1) || major > 4;
	GLAD_GL_VERSION_4_2 = (major == 4 && minor >= 2) || major > 4;
	GLAD_GL_VERSION_4_3 = (major == 4 && minor >= 3) || major > 4;
	GLAD_GL_VERSION_4_4 = (major == 4 && minor >= 4) || major > 4;
	GLAD_GL_VERSION_4_5 = (major == 4 && minor >= 5) || major > 4;
	GLAD_GL_VERSION_4_6 = (major == 4 && minor >= 6) || major > 4;
	if (GLVersion.major > 4 || (GLVersion.major >= 4 && GLVersion.minor >= 6)) {
		max_loaded_major = 4;
		max_loaded_minor = 6;
	}
}

int gladLoadGLLoader(GLADloadproc load) {
	GLVersion.major = 0;
	GLVersion.minor = 0;
	glad_glGetString = (PFNGLGETSTRINGPROC)load("glGetString");
	if(glad_glGetString == NULL) return 0;
	if(glad_glGetString(GL_VERSION) == NULL) return 0;
	find_coreGL();
	load_GL_VERSION_1_0(load);
	load_GL_VERSION_1_1(load);
	load_GL_VERSION_1_2(load);
	load_GL_VERSION_1_3(load);
	load_GL_VERSION_1_4(load);
	load_GL_VERSION_1_5(load);
	load_GL_VERSION_2_0(load);
	load_GL_VERSION_2_1(load);
	load_GL_VERSION_3_0(load);
	load_GL_VERSION_3_1(load);
	load_GL_VERSION_3_2(load);
	load_GL_VERSION_3_3(load);
	load_GL_VERSION_4_0(load);
	load_GL_VERSION_4_1(load);
	load_GL_VERSION_4_2(load);
	load_GL_VERSION_4_3(load);
	load_GL_VERSION_4_4(load);
	load_GL_VERSION_4_5(load);
	load_GL_VERSION_4_6(load);

	if (!find_extensionsGL()) return 0;
	return GLVersion.major != 0 || GLVersion.minor != 0;
}


// 1.0
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glCullFace(GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCullFace(mode);
}
GLAPI void glFrontFace(GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFrontFace(mode);
}
GLAPI void glHint(GLenum target, GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glHint(target, mode);
}
GLAPI void glLineWidth(GLfloat width) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glLineWidth(width);
}
GLAPI void glPointSize(GLfloat size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPointSize(size);
}
GLAPI void glPolygonMode(GLenum face, GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPolygonMode(face, mode);
}
GLAPI void glScissor(GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glScissor(x, y, width, height);
}
GLAPI void glTexParameterf(GLenum target, GLenum pname, GLfloat param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexParameterf(target, pname, param);
}
GLAPI void glTexParameterfv(GLenum target, GLenum pname, const GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexParameterfv(target, pname, params);
}
GLAPI void glTexParameteri(GLenum target, GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexParameteri(target, pname, param);
}
GLAPI void glTexParameteriv(GLenum target, GLenum pname, const GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexParameteriv(target, pname, params);
}
GLAPI void glTexImage1D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLint border, GLenum format, GLenum type, const void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexImage1D(target, level, internalformat, width, border, format, type, pixels);
}
GLAPI void glTexImage2D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexImage2D(target, level, internalformat, width, height, border, format, type, pixels);
}
GLAPI void glDrawBuffer(GLenum buf) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawBuffer(buf);
}
GLAPI void glClear(GLbitfield mask) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClear(mask);
}
GLAPI void glClearColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearColor(red, green, blue, alpha);
}
GLAPI void glClearStencil(GLint s) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearStencil(s);
}
GLAPI void glClearDepth(GLdouble depth) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearDepth(depth);
}
GLAPI void glStencilMask(GLuint mask) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glStencilMask(mask);
}
GLAPI void glColorMask(GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glColorMask(red, green, blue, alpha);
}
GLAPI void glDepthMask(GLboolean flag) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDepthMask(flag);
}
GLAPI void glDisable(GLenum cap) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDisable(cap);
}
GLAPI void glEnable(GLenum cap) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEnable(cap);
}
GLAPI void glFinish() {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFinish();
}
GLAPI void glFlush() {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFlush();
}
GLAPI void glBlendFunc(GLenum sfactor, GLenum dfactor) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendFunc(sfactor, dfactor);
}
GLAPI void glLogicOp(GLenum opcode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glLogicOp(opcode);
}
GLAPI void glStencilFunc(GLenum func, GLint ref, GLuint mask) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glStencilFunc(func, ref, mask);
}
GLAPI void glStencilOp(GLenum fail, GLenum zfail, GLenum zpass) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glStencilOp(fail, zfail, zpass);
}
GLAPI void glDepthFunc(GLenum func) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDepthFunc(func);
}
GLAPI void glPixelStoref(GLenum pname, GLfloat param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPixelStoref(pname, param);
}
GLAPI void glPixelStorei(GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPixelStorei(pname, param);
}
GLAPI void glReadBuffer(GLenum src) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glReadBuffer(src);
}
GLAPI void glReadPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glReadPixels(x, y, width, height, format, type, pixels);
}
GLAPI void glGetBooleanv(GLenum pname, GLboolean* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetBooleanv(pname, data);
}
GLAPI void glGetDoublev(GLenum pname, GLdouble* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetDoublev(pname, data);
}
GLAPI GLenum glGetError() {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetError();
}
GLAPI void glGetFloatv(GLenum pname, GLfloat* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetFloatv(pname, data);
}
GLAPI void glGetIntegerv(GLenum pname, GLint* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetIntegerv(pname, data);
}
GLAPI const GLubyte* glGetString(GLenum name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetString(name);
}
GLAPI void glGetTexImage(GLenum target, GLint level, GLenum format, GLenum type, void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexImage(target, level, format, type, pixels);
}
GLAPI void glGetTexParameterfv(GLenum target, GLenum pname, GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexParameterfv(target, pname, params);
}
GLAPI void glGetTexParameteriv(GLenum target, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexParameteriv(target, pname, params);
}
GLAPI void glGetTexLevelParameterfv(GLenum target, GLint level, GLenum pname, GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexLevelParameterfv(target, level, pname, params);
}
GLAPI void glGetTexLevelParameteriv(GLenum target, GLint level, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexLevelParameteriv(target, level, pname, params);
}
GLAPI GLboolean glIsEnabled(GLenum cap) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsEnabled(cap);
}
GLAPI void glDepthRange(GLdouble n, GLdouble f) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDepthRange(n, f);
}
GLAPI void glViewport(GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glViewport(x, y, width, height);
}
#endif

// 1.1
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glDrawArrays(GLenum mode, GLint first, GLsizei count) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawArrays(mode, first, count);
}
GLAPI void glDrawElements(GLenum mode, GLsizei count, GLenum type, const void* indices) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElements(mode, count, type, indices);
}
GLAPI void glPolygonOffset(GLfloat factor, GLfloat units) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPolygonOffset(factor, units);
}
GLAPI void glCopyTexImage1D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLint border) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTexImage1D(target, level, internalformat, x, y, width, border);
}
GLAPI void glCopyTexImage2D(GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTexImage2D(target, level, internalformat, x, y, width, height, border);
}
GLAPI void glCopyTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTexSubImage1D(target, level, xoffset, x, y, width);
}
GLAPI void glCopyTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTexSubImage2D(target, level, xoffset, yoffset, x, y, width, height);
}
GLAPI void glTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexSubImage1D(target, level, xoffset, width, format, type, pixels);
}
GLAPI void glTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexSubImage2D(target, level, xoffset, yoffset, width, height, format, type, pixels);
}
GLAPI void glBindTexture(GLenum target, GLuint texture) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindTexture(target, texture);
}
GLAPI void glDeleteTextures(GLsizei n, const GLuint* textures) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteTextures(n, textures);
}
GLAPI void glGenTextures(GLsizei n, GLuint* textures) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenTextures(n, textures);
}
GLAPI GLboolean glIsTexture(GLuint texture) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsTexture(texture);
}
#endif

// 1.2
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glDrawRangeElements(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawRangeElements(mode, start, end, count, type, indices);
}
GLAPI void glTexImage3D(GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLenum format, GLenum type, const void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexImage3D(target, level, internalformat, width, height, depth, border, format, type, pixels);
}
GLAPI void glTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void* pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}
GLAPI void glCopyTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTexSubImage3D(target, level, xoffset, yoffset, zoffset, x, y, width, height);
}
#endif

// 1.3
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glActiveTexture(GLenum texture) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glActiveTexture(texture);
}
GLAPI void glSampleCoverage(GLfloat value, GLboolean invert) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSampleCoverage(value, invert);
}
GLAPI void glCompressedTexImage3D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLint border, GLsizei imageSize, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTexImage3D(target, level, internalformat, width, height, depth, border, imageSize, data);
}
GLAPI void glCompressedTexImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTexImage2D(target, level, internalformat, width, height, border, imageSize, data);
}
GLAPI void glCompressedTexImage1D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLint border, GLsizei imageSize, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTexImage1D(target, level, internalformat, width, border, imageSize, data);
}
GLAPI void glCompressedTexSubImage3D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTexSubImage3D(target, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}
GLAPI void glCompressedTexSubImage2D(GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTexSubImage2D(target, level, xoffset, yoffset, width, height, format, imageSize, data);
}
GLAPI void glCompressedTexSubImage1D(GLenum target, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTexSubImage1D(target, level, xoffset, width, format, imageSize, data);
}
GLAPI void glGetCompressedTexImage(GLenum target, GLint level, void* img) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetCompressedTexImage(target, level, img);
}
#endif

// 1.4
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glBlendFuncSeparate(GLenum sfactorRGB, GLenum dfactorRGB, GLenum sfactorAlpha, GLenum dfactorAlpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendFuncSeparate(sfactorRGB, dfactorRGB, sfactorAlpha, dfactorAlpha);
}
GLAPI void glMultiDrawArrays(GLenum mode, const GLint* first, const GLsizei* count, GLsizei drawcount) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawArrays(mode, first, count, drawcount);
}
GLAPI void glMultiDrawElements(GLenum mode, const GLsizei* count, GLenum type, const void* const* indices, GLsizei drawcount) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawElements(mode, count, type, indices, drawcount);
}
GLAPI void glPointParameterf(GLenum pname, GLfloat param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPointParameterf(pname, param);
}
GLAPI void glPointParameterfv(GLenum pname, const GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPointParameterfv(pname, params);
}
GLAPI void glPointParameteri(GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPointParameteri(pname, param);
}
GLAPI void glPointParameteriv(GLenum pname, const GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPointParameteriv(pname, params);
}
GLAPI void glBlendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendColor(red, green, blue, alpha);
}
GLAPI void glBlendEquation(GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendEquation(mode);
}
#endif

// 1.5
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glGenQueries(GLsizei n, GLuint* ids) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenQueries(n, ids);
}
GLAPI void glDeleteQueries(GLsizei n, const GLuint* ids) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteQueries(n, ids);
}
GLAPI GLboolean glIsQuery(GLuint id) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsQuery(id);
}
GLAPI void glBeginQuery(GLenum target, GLuint id) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBeginQuery(target, id);
}
GLAPI void glEndQuery(GLenum target) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEndQuery(target);
}
GLAPI void glGetQueryiv(GLenum target, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryiv(target, pname, params);
}
GLAPI void glGetQueryObjectiv(GLuint id, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryObjectiv(id, pname, params);
}
GLAPI void glGetQueryObjectuiv(GLuint id, GLenum pname, GLuint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryObjectuiv(id, pname, params);
}
GLAPI void glBindBuffer(GLenum target, GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindBuffer(target, buffer);
}
GLAPI void glDeleteBuffers(GLsizei n, const GLuint* buffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteBuffers(n, buffers);
}
GLAPI void glGenBuffers(GLsizei n, GLuint* buffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenBuffers(n, buffers);
}
GLAPI GLboolean glIsBuffer(GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsBuffer(buffer);
}
GLAPI void glBufferData(GLenum target, GLsizeiptr size, const void* data, GLenum usage) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBufferData(target, size, data, usage);
}
GLAPI void glBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, const void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBufferSubData(target, offset, size, data);
}
GLAPI void glGetBufferSubData(GLenum target, GLintptr offset, GLsizeiptr size, void* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetBufferSubData(target, offset, size, data);
}
GLAPI void* glMapBuffer(GLenum target, GLenum access) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glMapBuffer(target, access);
}
GLAPI GLboolean glUnmapBuffer(GLenum target) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glUnmapBuffer(target);
}
GLAPI void glGetBufferParameteriv(GLenum target, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetBufferParameteriv(target, pname, params);
}
GLAPI void glGetBufferPointerv(GLenum target, GLenum pname, void** params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetBufferPointerv(target, pname, params);
}
#endif

// 2.0
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glBlendEquationSeparate(GLenum modeRGB, GLenum modeAlpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendEquationSeparate(modeRGB, modeAlpha);
}
GLAPI void glDrawBuffers(GLsizei n, const GLenum* bufs) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawBuffers(n, bufs);
}
GLAPI void glStencilOpSeparate(GLenum face, GLenum sfail, GLenum dpfail, GLenum dppass) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glStencilOpSeparate(face, sfail, dpfail, dppass);
}
GLAPI void glStencilFuncSeparate(GLenum face, GLenum func, GLint ref, GLuint mask) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glStencilFuncSeparate(face, func, ref, mask);
}
GLAPI void glStencilMaskSeparate(GLenum face, GLuint mask) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glStencilMaskSeparate(face, mask);
}
GLAPI void glAttachShader(GLuint program, GLuint shader) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glAttachShader(program, shader);
}
GLAPI void glBindAttribLocation(GLuint program, GLuint index, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindAttribLocation(program, index, name);
}
GLAPI void glCompileShader(GLuint shader) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompileShader(shader);
}
GLAPI GLuint glCreateProgram() {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glCreateProgram();
}
GLAPI GLuint glCreateShader(GLenum type) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glCreateShader(type);
}
GLAPI void glDeleteProgram(GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteProgram(program);
}
GLAPI void glDeleteShader(GLuint shader) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteShader(shader);
}
GLAPI void glDetachShader(GLuint program, GLuint shader) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDetachShader(program, shader);
}
GLAPI void glDisableVertexAttribArray(GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDisableVertexAttribArray(index);
}
GLAPI void glEnableVertexAttribArray(GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEnableVertexAttribArray(index);
}
GLAPI void glGetActiveAttrib(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveAttrib(program, index, bufSize, length, size, type, name);
}
GLAPI void glGetActiveUniform(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLint* size, GLenum* type, GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveUniform(program, index, bufSize, length, size, type, name);;
}
GLAPI void glGetAttachedShaders(GLuint program, GLsizei maxCount, GLsizei* count, GLuint* shaders) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetAttachedShaders(program, maxCount, count, shaders);
}
GLAPI GLint glGetAttribLocation(GLuint program, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetAttribLocation(program, name);
}
GLAPI void glGetProgramiv(GLuint program, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramiv(program, pname, params);
}
GLAPI void glGetProgramInfoLog(GLuint program, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramInfoLog(program, bufSize, length, infoLog);
}
GLAPI void glGetShaderiv(GLuint shader, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetShaderiv(shader, pname, params);
}
GLAPI void glGetShaderInfoLog(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* infoLog) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetShaderInfoLog(shader, bufSize, length, infoLog);
}
GLAPI void glGetShaderSource(GLuint shader, GLsizei bufSize, GLsizei* length, GLchar* source) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetShaderSource(shader, bufSize, length, source);
}
GLAPI GLint glGetUniformLocation(GLuint program, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetUniformLocation(program, name);
}
GLAPI void glGetUniformfv(GLuint program, GLint location, GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetUniformfv(program, location, params);
}
GLAPI void glGetUniformiv(GLuint program, GLint location, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetUniformiv(program, location, params);
}
GLAPI void glGetVertexAttribdv(GLuint index, GLenum pname, GLdouble* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribdv(index, pname, params);
}
GLAPI void glGetVertexAttribfv(GLuint index, GLenum pname, GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribfv(index, pname, params);
}
GLAPI void glGetVertexAttribiv(GLuint index, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribiv(index, pname, params);
}
GLAPI void glGetVertexAttribPointerv(GLuint index, GLenum pname, void** pointer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribPointerv(index, pname, pointer);
}
GLAPI GLboolean glIsProgram(GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsProgram(program);
}
GLAPI GLboolean glIsShader(GLuint shader) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsShader(shader);
}
GLAPI void glLinkProgram(GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glLinkProgram(program);
}
GLAPI void glShaderSource(GLuint shader, GLsizei count, const GLchar* const* string, const GLint* length) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glShaderSource(shader, count, string, length);
}
GLAPI void glUseProgram(GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUseProgram(program);
}
GLAPI void glUniform1f(GLint location, GLfloat v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1f(location, v0);
}
GLAPI void glUniform2f(GLint location, GLfloat v0, GLfloat v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2f(location, v0, v1);
}
GLAPI void glUniform3f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3f(location, v0, v1, v2);
}
GLAPI void glUniform4f(GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4f(location, v0, v1, v2, v3);
}
GLAPI void glUniform1i(GLint location, GLint v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1i(location, v0);
}
GLAPI void glUniform2i(GLint location, GLint v0, GLint v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2i(location, v0, v1);
}
GLAPI void glUniform3i(GLint location, GLint v0, GLint v1, GLint v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3i(location, v0, v1, v2);
}
GLAPI void glUniform4i(GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4i(location, v0, v1, v2, v3);
}
GLAPI void glUniform1fv(GLint location, GLsizei count, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1fv(location, count, value);
}
GLAPI void glUniform2fv(GLint location, GLsizei count, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2fv(location, count, value);
}
GLAPI void glUniform3fv(GLint location, GLsizei count, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3fv(location, count, value);
}
GLAPI void glUniform4fv(GLint location, GLsizei count, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4fv(location, count, value);
}
GLAPI void glUniform1iv(GLint location, GLsizei count, const GLint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1iv(location, count, value);
}
GLAPI void glUniform2iv(GLint location, GLsizei count, const GLint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2iv(location, count, value);
}
GLAPI void glUniform3iv(GLint location, GLsizei count, const GLint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3iv(location, count, value);
}
GLAPI void glUniform4iv(GLint location, GLsizei count, const GLint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4iv(location, count, value);
}
GLAPI void glUniformMatrix2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix2fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix3fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix4fv(location, count, transpose, value);
}
GLAPI void glValidateProgram(GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glValidateProgram(program);
}
GLAPI void glVertexAttrib1d(GLuint index, GLdouble x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib1d(index, x);
}
GLAPI void glVertexAttrib1dv(GLuint index, const GLdouble* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib1dv(index, v);
}
GLAPI void glVertexAttrib1f(GLuint index, GLfloat x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib1f(index, x);
}
GLAPI void glVertexAttrib1fv(GLuint index, const GLfloat* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib1fv(index, v);
}
GLAPI void glVertexAttrib1s(GLuint index, GLshort x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib1s(index, x);
}
GLAPI void glVertexAttrib1sv(GLuint index, const GLshort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib1sv(index, v);
}
GLAPI void glVertexAttrib2d(GLuint index, GLdouble x, GLdouble y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib2d(index, x, y);
}
GLAPI void glVertexAttrib2dv(GLuint index, const GLdouble* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib2dv(index, v);
}
GLAPI void glVertexAttrib2f(GLuint index, GLfloat x, GLfloat y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib2f(index, x, y);
}
GLAPI void glVertexAttrib2fv(GLuint index, const GLfloat* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib2fv(index, v);
}
GLAPI void glVertexAttrib2s(GLuint index, GLshort x, GLshort y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib2s(index, x, y);
}
GLAPI void glVertexAttrib2sv(GLuint index, const GLshort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib2sv(index, v);
}
GLAPI void glVertexAttrib3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib3d(index, x, y, z);
}
GLAPI void glVertexAttrib3dv(GLuint index, const GLdouble* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib3dv(index, v);
}
GLAPI void glVertexAttrib3f(GLuint index, GLfloat x, GLfloat y, GLfloat z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib3f(index, x, y, z);
}
GLAPI void glVertexAttrib3fv(GLuint index, const GLfloat* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib3fv(index, v);
}
GLAPI void glVertexAttrib3s(GLuint index, GLshort x, GLshort y, GLshort z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib3s(index, x, y, z);
}
GLAPI void glVertexAttrib3sv(GLuint index, const GLshort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib3sv(index, v);
}
GLAPI void glVertexAttrib4Nbv(GLuint index, const GLbyte* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Nbv(index, v);
}
GLAPI void glVertexAttrib4Niv(GLuint index, const GLint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Niv(index, v);
}
GLAPI void glVertexAttrib4Nsv(GLuint index, const GLshort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Nsv(index, v);
}
GLAPI void glVertexAttrib4Nub(GLuint index, GLubyte x, GLubyte y, GLubyte z, GLubyte w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Nub(index, x, y, z, w);
}
GLAPI void glVertexAttrib4Nubv(GLuint index, const GLubyte* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Nubv(index, v);
}
GLAPI void glVertexAttrib4Nuiv(GLuint index, const GLuint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Nuiv(index, v);
}
GLAPI void glVertexAttrib4Nusv(GLuint index, const GLushort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4Nusv(index, v);
}
GLAPI void glVertexAttrib4bv(GLuint index, const GLbyte* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4bv(index, v);
}
GLAPI void glVertexAttrib4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4d(index, x, y, z, w);
}
GLAPI void glVertexAttrib4dv(GLuint index, const GLdouble* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4dv(index, v);
}
GLAPI void glVertexAttrib4f(GLuint index, GLfloat x, GLfloat y, GLfloat z, GLfloat w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4f(index, x, y, z, w);
}
GLAPI void glVertexAttrib4fv(GLuint index, const GLfloat* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4fv(index, v);
}
GLAPI void glVertexAttrib4iv(GLuint index, const GLint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4iv(index, v);
}
GLAPI void glVertexAttrib4s(GLuint index, GLshort x, GLshort y, GLshort z, GLshort w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4s(index, x, y, z, w);
}
GLAPI void glVertexAttrib4sv(GLuint index, const GLshort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4sv(index, v);
}
GLAPI void glVertexAttrib4ubv(GLuint index, const GLubyte* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4ubv(index, v);
}
GLAPI void glVertexAttrib4uiv(GLuint index, const GLuint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4uiv(index, v);
}
GLAPI void glVertexAttrib4usv(GLuint index, const GLushort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttrib4usv(index, v);
}
GLAPI void glVertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const void* pointer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribPointer(index, size, type, normalized, stride, pointer);
}
#endif

// 2.1
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glUniformMatrix2x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix2x3fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix3x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix3x2fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix2x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix2x4fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix4x2fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix4x2fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix3x4fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix3x4fv(location, count, transpose, value);
}
GLAPI void glUniformMatrix4x3fv(GLint location, GLsizei count, GLboolean transpose, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix4x3fv(location, count, transpose, value);
}
#endif

// 3.0
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glColorMaski(GLuint index, GLboolean r, GLboolean g, GLboolean b, GLboolean a) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glColorMaski(index, r, g, b, a);
}
GLAPI void glGetBooleani_v(GLenum target, GLuint index, GLboolean* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetBooleani_v(target, index, data);
}
GLAPI void glGetIntegeri_v(GLenum target, GLuint index, GLint* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetIntegeri_v(target, index, data);
}
GLAPI void glEnablei(GLenum target, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEnablei(target, index);
}
GLAPI void glDisablei(GLenum target, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDisablei(target, index);
}
GLAPI GLboolean glIsEnabledi(GLenum target, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsEnabledi(target, index);
}
GLAPI void glBeginTransformFeedback(GLenum primitiveMode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBeginTransformFeedback(primitiveMode);
}
GLAPI void glEndTransformFeedback() {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEndTransformFeedback();
}
GLAPI void glBindBufferRange(GLenum target, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindBufferRange(target, index, buffer, offset, size);
}
GLAPI void glBindBufferBase(GLenum target, GLuint index, GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindBufferBase(target, index, buffer);
}
GLAPI void glTransformFeedbackVaryings(GLuint program, GLsizei count, const GLchar* const* varyings, GLenum bufferMode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTransformFeedbackVaryings(program, count, varyings, bufferMode);
}
GLAPI void glGetTransformFeedbackVarying(GLuint program, GLuint index, GLsizei bufSize, GLsizei* length, GLsizei* size, GLenum* type, GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTransformFeedbackVarying(program, index, bufSize, length, size, type, name);
}
GLAPI void glClampColor(GLenum target, GLenum clamp) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClampColor(target, clamp);
}
GLAPI void glBeginConditionalRender(GLuint id, GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBeginConditionalRender(id, mode);
}
GLAPI void glEndConditionalRender() {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEndConditionalRender();
}
GLAPI void glVertexAttribIPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void* pointer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribIPointer(index, size, type, stride, pointer);
}
GLAPI void glGetVertexAttribIiv(GLuint index, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribIiv(index, pname, params);
}
GLAPI void glGetVertexAttribIuiv(GLuint index, GLenum pname, GLuint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribIuiv(index, pname, params);
}
GLAPI void glVertexAttribI1i(GLuint index, GLint x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI1i(index, x);
}
GLAPI void glVertexAttribI2i(GLuint index, GLint x, GLint y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI2i(index, x, y);
}
GLAPI void glVertexAttribI3i(GLuint index, GLint x, GLint y, GLint z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI3i(index, x, y, z);
}
GLAPI void glVertexAttribI4i(GLuint index, GLint x, GLint y, GLint z, GLint w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4i(index, x, y, z, w);
}
GLAPI void glVertexAttribI1ui(GLuint index, GLuint x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI1ui(index, x);
}
GLAPI void glVertexAttribI2ui(GLuint index, GLuint x, GLuint y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI2ui(index, x, y);
}
GLAPI void glVertexAttribI3ui(GLuint index, GLuint x, GLuint y, GLuint z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI3ui(index, x, y, z);
}
GLAPI void glVertexAttribI4ui(GLuint index, GLuint x, GLuint y, GLuint z, GLuint w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4ui(index, x, y, z, w);
}
GLAPI void glVertexAttribI1iv(GLuint index, const GLint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI1iv(index, v);
}
GLAPI void glVertexAttribI2iv(GLuint index, const GLint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI2iv(index, v);
}
GLAPI void glVertexAttribI3iv(GLuint index, const GLint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI3iv(index, v);
}
GLAPI void glVertexAttribI4iv(GLuint index, const GLint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4iv(index, v);
}
GLAPI void glVertexAttribI1uiv(GLuint index, const GLuint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI1uiv(index, v);
}
GLAPI void glVertexAttribI2uiv(GLuint index, const GLuint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI2uiv(index, v);
}
GLAPI void glVertexAttribI3uiv(GLuint index, const GLuint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI3uiv(index, v);
}
GLAPI void glVertexAttribI4uiv(GLuint index, const GLuint* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4uiv(index, v);
}
GLAPI void glVertexAttribI4bv(GLuint index, const GLbyte* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4bv(index, v);
}
GLAPI void glVertexAttribI4sv(GLuint index, const GLshort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4sv(index, v);
}
GLAPI void glVertexAttribI4ubv(GLuint index, const GLubyte* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4ubv(index, v);
}
GLAPI void glVertexAttribI4usv(GLuint index, const GLushort* v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribI4usv(index, v);
}
GLAPI void glGetUniformuiv(GLuint program, GLint location, GLuint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetUniformuiv(program, location, params);
}
GLAPI void glBindFragDataLocation(GLuint program, GLuint color, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindFragDataLocation(program, color, name);
}
GLAPI GLint glGetFragDataLocation(GLuint program, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetFragDataLocation(program, name);
}
GLAPI void glUniform1ui(GLint location, GLuint v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1ui(location, v0);
}
GLAPI void glUniform2ui(GLint location, GLuint v0, GLuint v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2ui(location, v0, v1);
}
GLAPI void glUniform3ui(GLint location, GLuint v0, GLuint v1, GLuint v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3ui(location, v0, v1, v2);
}
GLAPI void glUniform4ui(GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4ui(location, v0, v1, v2, v3);
}
GLAPI void glUniform1uiv(GLint location, GLsizei count, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1uiv(location, count, value);
}
GLAPI void glUniform2uiv(GLint location, GLsizei count, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2uiv(location, count, value);
}
GLAPI void glUniform3uiv(GLint location, GLsizei count, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3uiv(location, count, value);
}
GLAPI void glUniform4uiv(GLint location, GLsizei count, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4uiv(location, count, value);
}
GLAPI void glTexParameterIiv(GLenum target, GLenum pname, const GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexParameterIiv(target, pname, params);
}
GLAPI void glTexParameterIuiv(GLenum target, GLenum pname, const GLuint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexParameterIuiv(target, pname, params);
}
GLAPI void glGetTexParameterIiv(GLenum target, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexParameterIiv(target, pname, params);
}
GLAPI void glGetTexParameterIuiv(GLenum target, GLenum pname, GLuint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTexParameterIuiv(target, pname, params);
}
GLAPI void glClearBufferiv(GLenum buffer, GLint drawbuffer, const GLint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearBufferiv(buffer, drawbuffer, value);
}
GLAPI void glClearBufferuiv(GLenum buffer, GLint drawbuffer, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearBufferuiv(buffer, drawbuffer, value);
}
GLAPI void glClearBufferfv(GLenum buffer, GLint drawbuffer, const GLfloat* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearBufferfv(buffer, drawbuffer, value);
}
GLAPI void glClearBufferfi(GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearBufferfi(buffer, drawbuffer, depth, stencil);
}
GLAPI const GLubyte* glGetStringi(GLenum name, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetStringi(name, index);
}
GLAPI GLboolean glIsRenderbuffer(GLuint renderbuffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsRenderbuffer(renderbuffer);
}
GLAPI void glBindRenderbuffer(GLenum target, GLuint renderbuffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindRenderbuffer(target, renderbuffer);
}
GLAPI void glDeleteRenderbuffers(GLsizei n, const GLuint* renderbuffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteRenderbuffers(n, renderbuffers);
}
GLAPI void glGenRenderbuffers(GLsizei n, GLuint* renderbuffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenRenderbuffers(n, renderbuffers);
}
GLAPI void glRenderbufferStorage(GLenum target, GLenum internalformat, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glRenderbufferStorage(target, internalformat, width, height);
}
GLAPI void glGetRenderbufferParameteriv(GLenum target, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetRenderbufferParameteriv(target, pname, params);
}
GLAPI GLboolean glIsFramebuffer(GLuint framebuffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsFramebuffer(framebuffer);
}
GLAPI void glBindFramebuffer(GLenum target, GLuint framebuffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindFramebuffer(target, framebuffer);
}
GLAPI void glDeleteFramebuffers(GLsizei n, const GLuint* framebuffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteFramebuffers(n, framebuffers);
}
GLAPI void glGenFramebuffers(GLsizei n, GLuint* framebuffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenFramebuffers(n, framebuffers);
}
GLAPI GLenum glCheckFramebufferStatus(GLenum target) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glCheckFramebufferStatus(target);
}
GLAPI void glFramebufferTexture1D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferTexture1D(target, attachment, textarget, texture, level);
}
GLAPI void glFramebufferTexture2D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferTexture2D(target, attachment, textarget, texture, level);
}
GLAPI void glFramebufferTexture3D(GLenum target, GLenum attachment, GLenum textarget, GLuint texture, GLint level, GLint zoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferTexture3D(target, attachment, textarget, texture, level, zoffset);
}
GLAPI void glFramebufferRenderbuffer(GLenum target, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferRenderbuffer(target, attachment, renderbuffertarget, renderbuffer);
}
GLAPI void glGetFramebufferAttachmentParameteriv(GLenum target, GLenum attachment, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetFramebufferAttachmentParameteriv(target, attachment, pname, params);
}
GLAPI void glGenerateMipmap(GLenum target) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenerateMipmap(target);
}
GLAPI void glBlitFramebuffer(GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlitFramebuffer(srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}
GLAPI void glRenderbufferStorageMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glRenderbufferStorageMultisample(target, samples, internalformat, width, height);
}
GLAPI void glFramebufferTextureLayer(GLenum target, GLenum attachment, GLuint texture, GLint level, GLint layer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferTextureLayer(target, attachment, texture, level, layer);
}
GLAPI void* glMapBufferRange(GLenum target, GLintptr offset, GLsizeiptr length, GLbitfield access) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glMapBufferRange(target, offset, length, access);
}
GLAPI void glFlushMappedBufferRange(GLenum target, GLintptr offset, GLsizeiptr length) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFlushMappedBufferRange(target, offset, length);
}
GLAPI void glBindVertexArray(GLuint array) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindVertexArray(array);
}
GLAPI void glDeleteVertexArrays(GLsizei n, const GLuint* arrays) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteVertexArrays(n, arrays);
}
GLAPI void glGenVertexArrays(GLsizei n, GLuint* arrays) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenVertexArrays(n, arrays);
}
GLAPI GLboolean glIsVertexArray(GLuint array) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsVertexArray(array);
}
#endif

// 3.1
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glDrawArraysInstanced(GLenum mode, GLint first, GLsizei count, GLsizei instancecount) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawArraysInstanced(mode, first, count, instancecount);
}
GLAPI void glDrawElementsInstanced(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElementsInstanced(mode, count, type, indices, instancecount);
}
GLAPI void glTexBuffer(GLenum target, GLenum internalformat, GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexBuffer(target, internalformat, buffer);
}
GLAPI void glPrimitiveRestartIndex(GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPrimitiveRestartIndex(index);
}
GLAPI void glCopyBufferSubData(GLenum readTarget, GLenum writeTarget, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyBufferSubData(readTarget, writeTarget, readOffset, writeOffset, size);
}
GLAPI void glGetUniformIndices(GLuint program, GLsizei uniformCount, const GLchar* const* uniformNames, GLuint* uniformIndices) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetUniformIndices(program, uniformCount, uniformNames, uniformIndices);
}
GLAPI void glGetActiveUniformsiv(GLuint program, GLsizei uniformCount, const GLuint* uniformIndices, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveUniformsiv(program, uniformCount, uniformIndices, pname, params);
}
GLAPI void glGetActiveUniformName(GLuint program, GLuint uniformIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformName) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveUniformName(program, uniformIndex, bufSize, length, uniformName);
}
GLAPI GLuint glGetUniformBlockIndex(GLuint program, const GLchar* uniformBlockName) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetUniformBlockIndex(program, uniformBlockName);
}
GLAPI void glGetActiveUniformBlockiv(GLuint program, GLuint uniformBlockIndex, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveUniformBlockiv(program, uniformBlockIndex, pname, params);
}
GLAPI void glGetActiveUniformBlockName(GLuint program, GLuint uniformBlockIndex, GLsizei bufSize, GLsizei* length, GLchar* uniformBlockName) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveUniformBlockName(program, uniformBlockIndex, bufSize, length, uniformBlockName);
}
GLAPI void glUniformBlockBinding(GLuint program, GLuint uniformBlockIndex, GLuint uniformBlockBinding) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformBlockBinding(program, uniformBlockIndex, uniformBlockBinding);
}
#endif

// 3.2
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glDrawElementsBaseVertex(GLenum mode, GLsizei count, GLenum type, const void* indices, GLint basevertex) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElementsBaseVertex(mode, count, type, indices, basevertex);
}
GLAPI void glDrawRangeElementsBaseVertex(GLenum mode, GLuint start, GLuint end, GLsizei count, GLenum type, const void* indices, GLint basevertex) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawRangeElementsBaseVertex(mode, start, end, count, type, indices, basevertex);
}
GLAPI void glDrawElementsInstancedBaseVertex(GLenum mode, GLsizei count, GLenum type, const void* indices, GLsizei instancecount, GLint basevertex) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElementsInstancedBaseVertex(mode, count, type, indices, instancecount, basevertex);
}
GLAPI void glMultiDrawElementsBaseVertex(GLenum mode, const GLsizei* count, GLenum type, const void* const* indices, GLsizei drawcount, const GLint* basevertex) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawElementsBaseVertex(mode, count, type, indices, drawcount, basevertex);
}
GLAPI void glProvokingVertex(GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProvokingVertex(mode);
}
GLAPI GLsync glFenceSync(GLenum condition, GLbitfield flags) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glFenceSync(condition, flags);
}
GLAPI GLboolean glIsSync(GLsync sync) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsSync(sync);
}
GLAPI void glDeleteSync(GLsync sync) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteSync(sync);
}
GLAPI GLenum glClientWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glClientWaitSync(sync, flags, timeout);
}
GLAPI void glWaitSync(GLsync sync, GLbitfield flags, GLuint64 timeout) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glWaitSync(sync, flags, timeout);
}
GLAPI void glGetInteger64v(GLenum pname, GLint64* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetInteger64v(pname, data);
}
GLAPI void glGetSynciv(GLsync sync, GLenum pname, GLsizei count, GLsizei* length, GLint* values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetSynciv(sync, pname, count, length, values);
}
GLAPI void glGetInteger64i_v(GLenum target, GLuint index, GLint64* data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetInteger64i_v(target, index, data);
}
GLAPI void glGetBufferParameteri64v(GLenum target, GLenum pname, GLint64* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetBufferParameteri64v(target, pname, params);
}
GLAPI void glFramebufferTexture(GLenum target, GLenum attachment, GLuint texture, GLint level) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferTexture(target, attachment, texture, level);
}
GLAPI void glTexImage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexImage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}
GLAPI void glTexImage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexImage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}
GLAPI void glGetMultisamplefv(GLenum pname, GLuint index, GLfloat* val) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetMultisamplefv(pname, index, val);
}
GLAPI void glSampleMaski(GLuint maskNumber, GLbitfield mask) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSampleMaski(maskNumber, mask);
}
#endif

// 3.3
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glBindFragDataLocationIndexed(GLuint program, GLuint colorNumber, GLuint index, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindFragDataLocationIndexed(program, colorNumber, index, name);
}
GLAPI GLint glGetFragDataIndex(GLuint program, const GLchar* name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetFragDataIndex(program, name);
}
GLAPI void glGenSamplers(GLsizei count, GLuint* samplers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenSamplers(count, samplers);
}
GLAPI void glDeleteSamplers(GLsizei count, const GLuint* samplers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteSamplers(count, samplers);
}
GLAPI GLboolean glIsSampler(GLuint sampler) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsSampler(sampler);
}
GLAPI void glBindSampler(GLuint unit, GLuint sampler) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindSampler(unit, sampler);
}
GLAPI void glSamplerParameteri(GLuint sampler, GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSamplerParameteri(sampler, pname, param);
}
GLAPI void glSamplerParameteriv(GLuint sampler, GLenum pname, const GLint* param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSamplerParameteriv(sampler, pname, param);
}
GLAPI void glSamplerParameterf(GLuint sampler, GLenum pname, GLfloat param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSamplerParameterf(sampler, pname, param);
}
GLAPI void glSamplerParameterfv(GLuint sampler, GLenum pname, const GLfloat* param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSamplerParameterfv(sampler, pname, param);
}
GLAPI void glSamplerParameterIiv(GLuint sampler, GLenum pname, const GLint* param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSamplerParameterIiv(sampler, pname, param);
}
GLAPI void glSamplerParameterIuiv(GLuint sampler, GLenum pname, const GLuint* param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSamplerParameterIuiv(sampler, pname, param);
}
GLAPI void glGetSamplerParameteriv(GLuint sampler, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetSamplerParameteriv(sampler, pname, params);
}
GLAPI void glGetSamplerParameterIiv(GLuint sampler, GLenum pname, GLint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetSamplerParameterIiv(sampler, pname, params);
}
GLAPI void glGetSamplerParameterfv(GLuint sampler, GLenum pname, GLfloat* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetSamplerParameterfv(sampler, pname, params);
}
GLAPI void glGetSamplerParameterIuiv(GLuint sampler, GLenum pname, GLuint* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetSamplerParameterIuiv(sampler, pname, params);
}
GLAPI void glQueryCounter(GLuint id, GLenum target) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glQueryCounter(id, target);
}
GLAPI void glGetQueryObjecti64v(GLuint id, GLenum pname, GLint64* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryObjecti64v(id, pname, params);
}
GLAPI void glGetQueryObjectui64v(GLuint id, GLenum pname, GLuint64* params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryObjectui64v(id, pname, params);
}
GLAPI void glVertexAttribDivisor(GLuint index, GLuint divisor) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribDivisor(index, divisor);
}
GLAPI void glVertexAttribP1ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP1ui(index, type, normalized, value);
}
GLAPI void glVertexAttribP1uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP1uiv(index, type, normalized, value);
}
GLAPI void glVertexAttribP2ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP2ui(index, type, normalized, value);
}
GLAPI void glVertexAttribP2uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP2uiv(index, type, normalized, value);
}
GLAPI void glVertexAttribP3ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP3ui(index, type, normalized, value);
}
GLAPI void glVertexAttribP3uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP3uiv(index, type, normalized, value);
}
GLAPI void glVertexAttribP4ui(GLuint index, GLenum type, GLboolean normalized, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP4ui(index, type, normalized, value);
}
GLAPI void glVertexAttribP4uiv(GLuint index, GLenum type, GLboolean normalized, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribP4uiv(index, type, normalized, value);
}
GLAPI void glVertexP2ui(GLenum type, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexP2ui(type, value);
}
GLAPI void glVertexP2uiv(GLenum type, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexP2uiv(type, value);
}
GLAPI void glVertexP3ui(GLenum type, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexP3ui(type, value);
}
GLAPI void glVertexP3uiv(GLenum type, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexP3uiv(type, value);
}
GLAPI void glVertexP4ui(GLenum type, GLuint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexP4ui(type, value);
}
GLAPI void glVertexP4uiv(GLenum type, const GLuint* value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexP4uiv(type, value);
}
GLAPI void glTexCoordP1ui(GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP1ui(type, coords);
}
GLAPI void glTexCoordP1uiv(GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP1uiv(type, coords);
}
GLAPI void glTexCoordP2ui(GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP2ui(type, coords);
}
GLAPI void glTexCoordP2uiv(GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP2uiv(type, coords);
}
GLAPI void glTexCoordP3ui(GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP3ui(type, coords);
}
GLAPI void glTexCoordP3uiv(GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP3uiv(type, coords);
}
GLAPI void glTexCoordP4ui(GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP4ui(type, coords);
}
GLAPI void glTexCoordP4uiv(GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexCoordP4uiv(type, coords);
}
GLAPI void glMultiTexCoordP1ui(GLenum texture, GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP1ui(texture, type, coords);
}
GLAPI void glMultiTexCoordP1uiv(GLenum texture, GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP1uiv(texture, type, coords);
}
GLAPI void glMultiTexCoordP2ui(GLenum texture, GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP2ui(texture, type, coords);
}
GLAPI void glMultiTexCoordP2uiv(GLenum texture, GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP2uiv(texture, type, coords);
}
GLAPI void glMultiTexCoordP3ui(GLenum texture, GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP3ui(texture, type, coords);
}
GLAPI void glMultiTexCoordP3uiv(GLenum texture, GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP3uiv(texture, type, coords);
}
GLAPI void glMultiTexCoordP4ui(GLenum texture, GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP4ui(texture, type, coords);
}
GLAPI void glMultiTexCoordP4uiv(GLenum texture, GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiTexCoordP4uiv(texture, type, coords);
}
GLAPI void glNormalP3ui(GLenum type, GLuint coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNormalP3ui(type, coords);
}
GLAPI void glNormalP3uiv(GLenum type, const GLuint* coords) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNormalP3uiv(type, coords);
}
GLAPI void glColorP3ui(GLenum type, GLuint color) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glColorP3ui(type, color);
}
GLAPI void glColorP3uiv(GLenum type, const GLuint* color) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glColorP3uiv(type, color);
}
GLAPI void glColorP4ui(GLenum type, GLuint color) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glColorP4ui(type, color);
}
GLAPI void glColorP4uiv(GLenum type, const GLuint* color) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glColorP4uiv(type, color);
}
GLAPI void glSecondaryColorP3ui(GLenum type, GLuint color) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSecondaryColorP3ui(type, color);
}
GLAPI void glSecondaryColorP3uiv(GLenum type, const GLuint* color) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSecondaryColorP3uiv(type, color);
}
#endif

// 4.0
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glMinSampleShading(GLfloat value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMinSampleShading(value);
}
GLAPI void glBlendEquationi(GLuint buf, GLenum mode) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendEquationi(buf, mode);
}
GLAPI void glBlendEquationSeparatei(GLuint buf, GLenum modeRGB, GLenum modeAlpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendEquationSeparatei(buf, modeRGB, modeAlpha);
}
GLAPI void glBlendFunci(GLuint buf, GLenum src, GLenum dst) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendFunci(buf, src, dst);
}
GLAPI void glBlendFuncSeparatei(GLuint buf, GLenum srcRGB, GLenum dstRGB, GLenum srcAlpha, GLenum dstAlpha) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlendFuncSeparatei(buf, srcRGB, dstRGB, srcAlpha, dstAlpha);
}
GLAPI void glDrawArraysIndirect(GLenum mode, const void *indirect) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawArraysIndirect(mode, indirect);
}
GLAPI void glDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElementsIndirect(mode, type, indirect);
}
GLAPI void glUniform1d(GLint location, GLdouble x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1d(location, x);
}
GLAPI void glUniform2d(GLint location, GLdouble x, GLdouble y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2d(location, x, y);
}
GLAPI void glUniform3d(GLint location, GLdouble x, GLdouble y, GLdouble z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3d(location, x, y, z);
}
GLAPI void glUniform4d(GLint location, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4d(location, x, y, z, w);
}
GLAPI void glUniform1dv(GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform1dv(location, count, value);
}
GLAPI void glUniform2dv(GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform2dv(location, count, value);
}
GLAPI void glUniform3dv(GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform3dv(location, count, value);
}
GLAPI void glUniform4dv(GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniform4dv(location, count, value);
}
GLAPI void glUniformMatrix2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix2dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix3dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix4dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix2x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix2x3dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix2x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix2x4dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix3x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix3x2dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix3x4dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix3x4dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix4x2dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix4x2dv(location, count, transpose, value);
}
GLAPI void glUniformMatrix4x3dv(GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformMatrix4x3dv(location, count, transpose, value);
}
GLAPI void glGetUniformdv(GLuint program, GLint location, GLdouble *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetUniformdv(program, location, params);
}
GLAPI GLint glGetSubroutineUniformLocation(GLuint program, GLenum shadertype, const GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetSubroutineUniformLocation(program, shadertype, name);
}
GLAPI GLuint glGetSubroutineIndex(GLuint program, GLenum shadertype, const GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetSubroutineIndex(program, shadertype, name);
}
GLAPI void glGetActiveSubroutineUniformiv(GLuint program, GLenum shadertype, GLuint index, GLenum pname, GLint *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveSubroutineUniformiv(program, shadertype, index, pname, values);
}
GLAPI void glGetActiveSubroutineUniformName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveSubroutineUniformName(program, shadertype, index, bufSize, length, name);
}
GLAPI void glGetActiveSubroutineName(GLuint program, GLenum shadertype, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveSubroutineName(program, shadertype, index, bufSize, length, name);
}
GLAPI void glUniformSubroutinesuiv(GLenum shadertype, GLsizei count, const GLuint *indices) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUniformSubroutinesuiv(shadertype, count, indices);
}
GLAPI void glGetUniformSubroutineuiv(GLenum shadertype, GLint location, GLuint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetUniformSubroutineuiv(shadertype, location, params);
}
GLAPI void glGetProgramStageiv(GLuint program, GLenum shadertype, GLenum pname, GLint *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramStageiv(program, shadertype, pname, values);
}
GLAPI void glPatchParameteri(GLenum pname, GLint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPatchParameteri(pname, value);
}
GLAPI void glPatchParameterfv(GLenum pname, const GLfloat *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPatchParameterfv(pname, values);
}
GLAPI void glBindTransformFeedback(GLenum target, GLuint id) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindTransformFeedback(target, id);
}
GLAPI void glDeleteTransformFeedbacks(GLsizei n, const GLuint *ids) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteTransformFeedbacks(n, ids);
}
GLAPI void glGenTransformFeedbacks(GLsizei n, GLuint *ids) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenTransformFeedbacks(n, ids);
}
GLAPI GLboolean glIsTransformFeedback(GLuint id) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsTransformFeedback(id);
}
GLAPI void glPauseTransformFeedback(void) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPauseTransformFeedback();
}
GLAPI void glResumeTransformFeedback(void) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glResumeTransformFeedback();
}
GLAPI void glDrawTransformFeedback(GLenum mode, GLuint id) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawTransformFeedback(mode, id);
}
GLAPI void glDrawTransformFeedbackStream(GLenum mode, GLuint id, GLuint stream) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawTransformFeedbackStream(mode, id, stream);
}
GLAPI void glBeginQueryIndexed(GLenum target, GLuint index, GLuint id) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBeginQueryIndexed(target, index, id);
}
GLAPI void glEndQueryIndexed(GLenum target, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEndQueryIndexed(target, index);
}
GLAPI void glGetQueryIndexediv(GLenum target, GLuint index, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryIndexediv(target, index, pname, params);
}
#endif

// 4.1
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glReleaseShaderCompiler(void) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glReleaseShaderCompiler();
}
GLAPI void glShaderBinary(GLsizei count, const GLuint *shaders, GLenum binaryFormat, const void *binary, GLsizei length) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glShaderBinary(count, shaders, binaryFormat, binary, length);
}
GLAPI void glGetShaderPrecisionFormat(GLenum shadertype, GLenum precisiontype, GLint *range, GLint *precision) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetShaderPrecisionFormat(shadertype, precisiontype, range, precision);
}
GLAPI void glDepthRangef(GLfloat n, GLfloat f) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDepthRangef(n, f);
}
GLAPI void glClearDepthf(GLfloat d) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearDepthf(d);
}
GLAPI void glGetProgramBinary(GLuint program, GLsizei bufSize, GLsizei *length, GLenum *binaryFormat, void *binary) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramBinary(program, bufSize, length, binaryFormat, binary);
}
GLAPI void glProgramBinary(GLuint program, GLenum binaryFormat, const void *binary, GLsizei length) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramBinary(program, binaryFormat, binary, length);
}
GLAPI void glProgramParameteri(GLuint program, GLenum pname, GLint value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramParameteri(program, pname, value);
}
GLAPI void glUseProgramStages(GLuint pipeline, GLbitfield stages, GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glUseProgramStages(pipeline, stages, program);
}
GLAPI void glActiveShaderProgram(GLuint pipeline, GLuint program) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glActiveShaderProgram(pipeline, program);
}
GLAPI GLuint glCreateShaderProgramv(GLenum type, GLsizei count, const GLchar *const*strings) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glCreateShaderProgramv(type, count, strings);
}
GLAPI void glBindProgramPipeline(GLuint pipeline) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindProgramPipeline(pipeline);
}
GLAPI void glDeleteProgramPipelines(GLsizei n, const GLuint *pipelines) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDeleteProgramPipelines(n, pipelines);
}
GLAPI void glGenProgramPipelines(GLsizei n, GLuint *pipelines) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenProgramPipelines(n, pipelines);
}
GLAPI GLboolean glIsProgramPipeline(GLuint pipeline) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glIsProgramPipeline(pipeline);
}
GLAPI void glGetProgramPipelineiv(GLuint pipeline, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramPipelineiv(pipeline, pname, params);
}
GLAPI void glProgramUniform1i(GLuint program, GLint location, GLint v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1i(program, location, v0);
}
GLAPI void glProgramUniform1iv(GLuint program, GLint location, GLsizei count, const GLint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1iv(program, location, count, value);
}
GLAPI void glProgramUniform1f(GLuint program, GLint location, GLfloat v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1f(program, location, v0);
}
GLAPI void glProgramUniform1fv(GLuint program, GLint location, GLsizei count, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1fv(program, location, count, value);
}
GLAPI void glProgramUniform1d(GLuint program, GLint location, GLdouble v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1d(program, location, v0);
}
GLAPI void glProgramUniform1dv(GLuint program, GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1dv(program, location, count, value);
}
GLAPI void glProgramUniform1ui(GLuint program, GLint location, GLuint v0) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1ui(program, location, v0);
}
GLAPI void glProgramUniform1uiv(GLuint program, GLint location, GLsizei count, const GLuint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform1uiv(program, location, count, value);
}
GLAPI void glProgramUniform2i(GLuint program, GLint location, GLint v0, GLint v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2i(program, location, v0, v1);
}
GLAPI void glProgramUniform2iv(GLuint program, GLint location, GLsizei count, const GLint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2iv(program, location, count, value);
}
GLAPI void glProgramUniform2f(GLuint program, GLint location, GLfloat v0, GLfloat v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2f(program, location, v0, v1);
}
GLAPI void glProgramUniform2fv(GLuint program, GLint location, GLsizei count, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2fv(program, location, count, value);
}
GLAPI void glProgramUniform2d(GLuint program, GLint location, GLdouble v0, GLdouble v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2d(program, location, v0, v1);
}
GLAPI void glProgramUniform2dv(GLuint program, GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2dv(program, location, count, value);
}
GLAPI void glProgramUniform2ui(GLuint program, GLint location, GLuint v0, GLuint v1) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2ui(program, location, v0, v1);
}
GLAPI void glProgramUniform2uiv(GLuint program, GLint location, GLsizei count, const GLuint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform2uiv(program, location, count, value);
}
GLAPI void glProgramUniform3i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3i(program, location, v0, v1, v2);
}
GLAPI void glProgramUniform3iv(GLuint program, GLint location, GLsizei count, const GLint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3iv(program, location, count, value);
}
GLAPI void glProgramUniform3f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3f(program, location, v0, v1, v2);
}
GLAPI void glProgramUniform3fv(GLuint program, GLint location, GLsizei count, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3fv(program, location, count, value);
}
GLAPI void glProgramUniform3d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3d(program, location, v0, v1, v2);
}
GLAPI void glProgramUniform3dv(GLuint program, GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3dv(program, location, count, value);
}
GLAPI void glProgramUniform3ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3ui(program, location, v0, v1, v2);
}
GLAPI void glProgramUniform3uiv(GLuint program, GLint location, GLsizei count, const GLuint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform3uiv(program, location, count, value);
}
GLAPI void glProgramUniform4i(GLuint program, GLint location, GLint v0, GLint v1, GLint v2, GLint v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4i(program, location, v0, v1, v2, v3);
}
GLAPI void glProgramUniform4iv(GLuint program, GLint location, GLsizei count, const GLint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4iv(program, location, count, value);
}
GLAPI void glProgramUniform4f(GLuint program, GLint location, GLfloat v0, GLfloat v1, GLfloat v2, GLfloat v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4f(program, location, v0, v1, v2, v3);
}
GLAPI void glProgramUniform4fv(GLuint program, GLint location, GLsizei count, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4fv(program, location, count, value);
}
GLAPI void glProgramUniform4d(GLuint program, GLint location, GLdouble v0, GLdouble v1, GLdouble v2, GLdouble v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4d(program, location, v0, v1, v2, v3);
}
GLAPI void glProgramUniform4dv(GLuint program, GLint location, GLsizei count, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4dv(program, location, count, value);
}
GLAPI void glProgramUniform4ui(GLuint program, GLint location, GLuint v0, GLuint v1, GLuint v2, GLuint v3) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4ui(program, location, v0, v1, v2, v3);
}
GLAPI void glProgramUniform4uiv(GLuint program, GLint location, GLsizei count, const GLuint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniform4uiv(program, location, count, value);
}
GLAPI void glProgramUniformMatrix2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix2fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix3fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix4fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix2dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix3dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix4dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix2x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix2x3fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix3x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix3x2fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix2x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix2x4fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix4x2fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix4x2fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix3x4fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix3x4fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix4x3fv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix4x3fv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix2x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix2x3dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix3x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix3x2dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix2x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix2x4dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix4x2dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix4x2dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix3x4dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix3x4dv(program, location, count, transpose, value);
}
GLAPI void glProgramUniformMatrix4x3dv(GLuint program, GLint location, GLsizei count, GLboolean transpose, const GLdouble *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glProgramUniformMatrix4x3dv(program, location, count, transpose, value);
}
GLAPI void glValidateProgramPipeline(GLuint pipeline) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glValidateProgramPipeline(pipeline);
}
GLAPI void glGetProgramPipelineInfoLog(GLuint pipeline, GLsizei bufSize, GLsizei *length, GLchar *infoLog) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramPipelineInfoLog(pipeline, bufSize, length, infoLog);
}
GLAPI void glVertexAttribL1d(GLuint index, GLdouble x) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL1d(index, x);
}
GLAPI void glVertexAttribL2d(GLuint index, GLdouble x, GLdouble y) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL2d(index, x, y);
}
GLAPI void glVertexAttribL3d(GLuint index, GLdouble x, GLdouble y, GLdouble z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL3d(index, x, y, z);
}
GLAPI void glVertexAttribL4d(GLuint index, GLdouble x, GLdouble y, GLdouble z, GLdouble w) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL4d(index, x, y, z, w);
}
GLAPI void glVertexAttribL1dv(GLuint index, const GLdouble *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL1dv(index, v);
}
GLAPI void glVertexAttribL2dv(GLuint index, const GLdouble *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL2dv(index, v);
}
GLAPI void glVertexAttribL3dv(GLuint index, const GLdouble *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL3dv(index, v);
}
GLAPI void glVertexAttribL4dv(GLuint index, const GLdouble *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribL4dv(index, v);
}
GLAPI void glVertexAttribLPointer(GLuint index, GLint size, GLenum type, GLsizei stride, const void *pointer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribLPointer(index, size, type, stride, pointer);
}
GLAPI void glGetVertexAttribLdv(GLuint index, GLenum pname, GLdouble *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexAttribLdv(index, pname, params);
}
GLAPI void glViewportArrayv(GLuint first, GLsizei count, const GLfloat *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glViewportArrayv(first, count, v);
}
GLAPI void glViewportIndexedf(GLuint index, GLfloat x, GLfloat y, GLfloat w, GLfloat h) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glViewportIndexedf(index, x, y, w, h);
}
GLAPI void glViewportIndexedfv(GLuint index, const GLfloat *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glViewportIndexedfv(index, v);
}
GLAPI void glScissorArrayv(GLuint first, GLsizei count, const GLint *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glScissorArrayv(first, count, v);
}
GLAPI void glScissorIndexed(GLuint index, GLint left, GLint bottom, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glScissorIndexed(index, left, bottom, width, height);
}
GLAPI void glScissorIndexedv(GLuint index, const GLint *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glScissorIndexedv(index, v);
}
GLAPI void glDepthRangeArrayv(GLuint first, GLsizei count, const GLdouble *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDepthRangeArrayv(first, count, v);
}
GLAPI void glDepthRangeIndexed(GLuint index, GLdouble n, GLdouble f) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDepthRangeIndexed(index, n, f);
}
GLAPI void glGetFloati_v(GLenum target, GLuint index, GLfloat *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetFloati_v(target, index, data);
}
GLAPI void glGetDoublei_v(GLenum target, GLuint index, GLdouble *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetDoublei_v(target, index, data);
}
#endif

// 4.2
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glDrawArraysInstancedBaseInstance(GLenum mode, GLint first, GLsizei count, GLsizei instancecount, GLuint baseinstance) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawArraysInstancedBaseInstance(mode, first, count, instancecount, baseinstance);
}
GLAPI void glDrawElementsInstancedBaseInstance(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLuint baseinstance) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElementsInstancedBaseInstance(mode, count, type, indices, instancecount, baseinstance);
}
GLAPI void glDrawElementsInstancedBaseVertexBaseInstance(GLenum mode, GLsizei count, GLenum type, const void *indices, GLsizei instancecount, GLint basevertex, GLuint baseinstance) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawElementsInstancedBaseVertexBaseInstance(mode, count, type, indices, instancecount, basevertex, baseinstance);
}
GLAPI void glGetInternalformativ(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetInternalformativ(target, internalformat, pname, count, params);
}
GLAPI void glGetActiveAtomicCounterBufferiv(GLuint program, GLuint bufferIndex, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetActiveAtomicCounterBufferiv(program, bufferIndex,pname, params);
}
GLAPI void glBindImageTexture(GLuint unit, GLuint texture, GLint level, GLboolean layered, GLint layer, GLenum access, GLenum format) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindImageTexture(unit, texture, level, layered, layer, access, format);
}
GLAPI void glMemoryBarrier(GLbitfield barriers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMemoryBarrier(barriers);
}
GLAPI void glTexStorage1D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexStorage1D(target, levels, internalformat, width);
}
GLAPI void glTexStorage2D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexStorage2D(target, levels, internalformat, width, height);
}
GLAPI void glTexStorage3D(GLenum target, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexStorage3D(target, levels, internalformat, width, height, depth);
}
GLAPI void glDrawTransformFeedbackInstanced(GLenum mode, GLuint id, GLsizei instancecount) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawTransformFeedbackInstanced(mode, id, instancecount);
}
GLAPI void glDrawTransformFeedbackStreamInstanced(GLenum mode, GLuint id, GLuint stream, GLsizei instancecount) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDrawTransformFeedbackStreamInstanced(mode, id, stream, instancecount);
}
#endif

// 4.3
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glClearBufferData(GLenum target, GLenum internalformat, GLenum format, GLenum type, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearBufferData(target, internalformat, format, type, data);
}
GLAPI void glClearBufferSubData(GLenum target, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearBufferSubData(target, internalformat, offset, size, format, type, data);
}
GLAPI void glDispatchCompute(GLuint num_groups_x, GLuint num_groups_y, GLuint num_groups_z) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDispatchCompute(num_groups_x, num_groups_y, num_groups_z);
}
GLAPI void glDispatchComputeIndirect(GLintptr indirect) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDispatchComputeIndirect(indirect);
}
GLAPI void glCopyImageSubData(GLuint srcName, GLenum srcTarget, GLint srcLevel, GLint srcX, GLint srcY, GLint srcZ, GLuint dstName, GLenum dstTarget, GLint dstLevel, GLint dstX, GLint dstY, GLint dstZ, GLsizei srcWidth, GLsizei srcHeight, GLsizei srcDepth) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyImageSubData(srcName, srcTarget, srcLevel, srcX, srcY, srcZ, dstName, dstTarget, dstLevel, dstX, dstY, dstZ, srcWidth, srcHeight, srcDepth);
}
GLAPI void glFramebufferParameteri(GLenum target, GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFramebufferParameteri(target, pname, param);
}
GLAPI void glGetFramebufferParameteriv(GLenum target, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetFramebufferParameteriv(target, pname, params);
}
GLAPI void glGetInternalformati64v(GLenum target, GLenum internalformat, GLenum pname, GLsizei count, GLint64 *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetInternalformati64v(target, internalformat, pname, count, params);
}
GLAPI void glInvalidateTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth);
}
GLAPI void glInvalidateTexImage(GLuint texture, GLint level) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateTexImage(texture, level);
}
GLAPI void glInvalidateBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr length) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateBufferSubData(buffer, offset, length);
}
GLAPI void glInvalidateBufferData(GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateBufferData(buffer);
}
GLAPI void glInvalidateFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateFramebuffer(target, numAttachments, attachments);
}
GLAPI void glInvalidateSubFramebuffer(GLenum target, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateSubFramebuffer(target, numAttachments, attachments, x, y, width, height);
}
GLAPI void glMultiDrawArraysIndirect(GLenum mode, const void *indirect, GLsizei drawcount, GLsizei stride) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawArraysIndirect(mode, indirect, drawcount, stride);
}
GLAPI void glMultiDrawElementsIndirect(GLenum mode, GLenum type, const void *indirect, GLsizei drawcount, GLsizei stride) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawElementsIndirect(mode, type, indirect, drawcount, stride);
}
GLAPI void glGetProgramInterfaceiv(GLuint program, GLenum programInterface, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramInterfaceiv(program, programInterface, pname, params);
}
GLAPI GLuint glGetProgramResourceIndex(GLuint program, GLenum programInterface, const GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetProgramResourceIndex(program, programInterface, name);
}
GLAPI void glGetProgramResourceName(GLuint program, GLenum programInterface, GLuint index, GLsizei bufSize, GLsizei *length, GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramResourceName(program, programInterface, index, bufSize, length, name);
}
GLAPI void glGetProgramResourceiv(GLuint program, GLenum programInterface, GLuint index, GLsizei propCount, const GLenum *props, GLsizei count, GLsizei *length, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetProgramResourceiv(program, programInterface, index, propCount, props, count, length, params);
}
GLAPI GLint glGetProgramResourceLocation(GLuint program, GLenum programInterface, const GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetProgramResourceLocation(program, programInterface, name);
}
GLAPI GLint glGetProgramResourceLocationIndex(GLuint program, GLenum programInterface, const GLchar *name) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetProgramResourceLocationIndex(program, programInterface, name);
}
GLAPI void glShaderStorageBlockBinding(GLuint program, GLuint storageBlockIndex, GLuint storageBlockBinding) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glShaderStorageBlockBinding(program, storageBlockIndex, storageBlockBinding);
}
GLAPI void glTexBufferRange(GLenum target, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexBufferRange(target, internalformat, buffer, offset, size);
}
GLAPI void glTexStorage2DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexStorage2DMultisample(target, samples, internalformat, width, height, fixedsamplelocations);
}
GLAPI void glTexStorage3DMultisample(GLenum target, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTexStorage3DMultisample(target, samples, internalformat, width, height, depth, fixedsamplelocations);
}
GLAPI void glTextureView(GLuint texture, GLenum target, GLuint origtexture, GLenum internalformat, GLuint minlevel, GLuint numlevels, GLuint minlayer, GLuint numlayers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureView(texture, target, origtexture, internalformat, minlevel, numlevels, minlayer, numlayers);
}
GLAPI void glBindVertexBuffer(GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindVertexBuffer(bindingindex, buffer, offset, stride);
}
GLAPI void glVertexAttribFormat(GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribFormat(attribindex, size, type, normalized, relativeoffset);
}
GLAPI void glVertexAttribIFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribIFormat(attribindex, size, type, relativeoffset);
}
GLAPI void glVertexAttribLFormat(GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribLFormat(attribindex, size, type, relativeoffset);
}
GLAPI void glVertexAttribBinding(GLuint attribindex, GLuint bindingindex) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexAttribBinding(attribindex, bindingindex);
}
GLAPI void glVertexBindingDivisor(GLuint bindingindex, GLuint divisor) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexBindingDivisor(bindingindex, divisor);
}
GLAPI void glDebugMessageControl(GLenum source, GLenum type, GLenum severity, GLsizei count, const GLuint *ids, GLboolean enabled) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDebugMessageControl(source, type, severity, count, ids, enabled);
}
GLAPI void glDebugMessageInsert(GLenum source, GLenum type, GLuint id, GLenum severity, GLsizei length, const GLchar *buf) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDebugMessageInsert(source, type, id, severity, length, buf);
}
GLAPI void glDebugMessageCallback(GLDEBUGPROC callback, const void *userParam) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDebugMessageCallback(callback, userParam);
}
GLAPI GLuint glGetDebugMessageLog(GLuint count, GLsizei bufSize, GLenum *sources, GLenum *types, GLuint *ids, GLenum *severities, GLsizei *lengths, GLchar *messageLog) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetDebugMessageLog(count, bufSize, sources, types, ids, severities, lengths, messageLog);
}
GLAPI void glPushDebugGroup(GLenum source, GLuint id, GLsizei length, const GLchar *message) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPushDebugGroup(source, id, length, message);
}
GLAPI void glPopDebugGroup(void) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPopDebugGroup();
}
GLAPI void glObjectLabel(GLenum identifier, GLuint name, GLsizei length, const GLchar *label) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glObjectLabel(identifier, name, length, label);
}
GLAPI void glGetObjectLabel(GLenum identifier, GLuint name, GLsizei bufSize, GLsizei *length, GLchar *label) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetObjectLabel(identifier, name, bufSize, length, label);
}
GLAPI void glObjectPtrLabel(const void *ptr, GLsizei length, const GLchar *label) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glObjectPtrLabel(ptr, length, label);
}
GLAPI void glGetObjectPtrLabel(const void *ptr, GLsizei bufSize, GLsizei *length, GLchar *label) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetObjectPtrLabel(ptr, bufSize, length, label);
}
GLAPI void glGetPointerv(GLenum pname, void **params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetPointerv(pname, params);
}
#endif

// 4.4
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glBufferStorage(GLenum target, GLsizeiptr size, const void *data, GLbitfield flags) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBufferStorage(target, size, data, flags);
}
GLAPI void glClearTexImage(GLuint texture, GLint level, GLenum format, GLenum type, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearTexImage(texture, level, format, type, data);
}
GLAPI void glClearTexSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearTexSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, data);
}
GLAPI void glBindBuffersBase(GLenum target, GLuint first, GLsizei count, const GLuint *buffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindBuffersBase(target, first, count, buffers);
}
GLAPI void glBindBuffersRange(GLenum target, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizeiptr *sizes) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindBuffersRange(target, first, count, buffers, offsets, sizes);
}
GLAPI void glBindTextures(GLuint first, GLsizei count, const GLuint *textures) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindTextures(first, count, textures);
}
GLAPI void glBindSamplers(GLuint first, GLsizei count, const GLuint *samplers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindSamplers(first, count, samplers);
}
GLAPI void glBindImageTextures(GLuint first, GLsizei count, const GLuint *textures) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindImageTextures(first, count, textures);
}
GLAPI void glBindVertexBuffers(GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindVertexBuffers(first, count, buffers, offsets, strides);
}
#endif

// 4.5
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glClipControl(GLenum origin, GLenum depth) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClipControl(origin, depth);
}
GLAPI void glCreateTransformFeedbacks(GLsizei n, GLuint *ids) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateTransformFeedbacks(n, ids);
}
GLAPI void glTransformFeedbackBufferBase(GLuint xfb, GLuint index, GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTransformFeedbackBufferBase(xfb, index, buffer);
}
GLAPI void glTransformFeedbackBufferRange(GLuint xfb, GLuint index, GLuint buffer, GLintptr offset, GLsizeiptr size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTransformFeedbackBufferRange(xfb, index, buffer, offset, size);
}
GLAPI void glGetTransformFeedbackiv(GLuint xfb, GLenum pname, GLint *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTransformFeedbackiv(xfb, pname, param);
}
GLAPI void glGetTransformFeedbacki_v(GLuint xfb, GLenum pname, GLuint index, GLint *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTransformFeedbacki_v(xfb, pname, index, param);
}
GLAPI void glGetTransformFeedbacki64_v(GLuint xfb, GLenum pname, GLuint index, GLint64 *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTransformFeedbacki64_v(xfb, pname, index, param);
}
GLAPI void glCreateBuffers(GLsizei n, GLuint *buffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateBuffers(n, buffers);
}
GLAPI void glNamedBufferStorage(GLuint buffer, GLsizeiptr size, const void *data, GLbitfield flags) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedBufferStorage(buffer, size, data, flags);
}
GLAPI void glNamedBufferData(GLuint buffer, GLsizeiptr size, const void *data, GLenum usage) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedBufferData(buffer, size, data, usage);
}
GLAPI void glNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedBufferSubData(buffer, offset, size, data);
}
GLAPI void glCopyNamedBufferSubData(GLuint readBuffer, GLuint writeBuffer, GLintptr readOffset, GLintptr writeOffset, GLsizeiptr size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyNamedBufferSubData(readBuffer, writeBuffer, readOffset, writeOffset, size);
}
GLAPI void glClearNamedBufferData(GLuint buffer, GLenum internalformat, GLenum format, GLenum type, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearNamedBufferData(buffer, internalformat, format, type, data);
}
GLAPI void glClearNamedBufferSubData(GLuint buffer, GLenum internalformat, GLintptr offset, GLsizeiptr size, GLenum format, GLenum type, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearNamedBufferSubData(buffer, internalformat, offset, size, format, type, data);
}
GLAPI void* glMapNamedBuffer(GLuint buffer, GLenum access) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glMapNamedBuffer(buffer, access);
}
GLAPI void* glMapNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length, GLbitfield access) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glMapNamedBufferRange(buffer, offset, length, access);
}
GLAPI GLboolean glUnmapNamedBuffer(GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glUnmapNamedBuffer(buffer);
}
GLAPI void glFlushMappedNamedBufferRange(GLuint buffer, GLintptr offset, GLsizeiptr length) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glFlushMappedNamedBufferRange(buffer, offset, length);
}
GLAPI void glGetNamedBufferParameteriv(GLuint buffer, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedBufferParameteriv(buffer, pname, params);
}
GLAPI void glGetNamedBufferParameteri64v(GLuint buffer, GLenum pname, GLint64 *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedBufferParameteri64v(buffer, pname, params);
}
GLAPI void glGetNamedBufferPointerv(GLuint buffer, GLenum pname, void **params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedBufferPointerv(buffer, pname, params);
}
GLAPI void glGetNamedBufferSubData(GLuint buffer, GLintptr offset, GLsizeiptr size, void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedBufferSubData(buffer, offset, size, data);
}
GLAPI void glCreateFramebuffers(GLsizei n, GLuint *framebuffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateFramebuffers(n, framebuffers);
}
GLAPI void glNamedFramebufferRenderbuffer(GLuint framebuffer, GLenum attachment, GLenum renderbuffertarget, GLuint renderbuffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferRenderbuffer(framebuffer, attachment, renderbuffertarget, renderbuffer);
}
GLAPI void glNamedFramebufferParameteri(GLuint framebuffer, GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferParameteri(framebuffer, pname, param);
}
GLAPI void glNamedFramebufferTexture(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferTexture(framebuffer, attachment, texture, level);
}
GLAPI void glNamedFramebufferTextureLayer(GLuint framebuffer, GLenum attachment, GLuint texture, GLint level, GLint layer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferTextureLayer(framebuffer, attachment, texture, level, layer);
}
GLAPI void glNamedFramebufferDrawBuffer(GLuint framebuffer, GLenum buf) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferDrawBuffer(framebuffer, buf);
}
GLAPI void glNamedFramebufferDrawBuffers(GLuint framebuffer, GLsizei n, const GLenum *bufs) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferDrawBuffers(framebuffer, n, bufs);
}
GLAPI void glNamedFramebufferReadBuffer(GLuint framebuffer, GLenum src) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedFramebufferReadBuffer(framebuffer, src);
}
GLAPI void glInvalidateNamedFramebufferData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateNamedFramebufferData(framebuffer, numAttachments, attachments);
}
GLAPI void glInvalidateNamedFramebufferSubData(GLuint framebuffer, GLsizei numAttachments, const GLenum *attachments, GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glInvalidateNamedFramebufferSubData(framebuffer, numAttachments, attachments, x, y, width, height);
}
GLAPI void glClearNamedFramebufferiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearNamedFramebufferiv(framebuffer, buffer, drawbuffer, value);
}
GLAPI void glClearNamedFramebufferuiv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLuint *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearNamedFramebufferuiv(framebuffer, buffer, drawbuffer, value);
}
GLAPI void glClearNamedFramebufferfv(GLuint framebuffer, GLenum buffer, GLint drawbuffer, const GLfloat *value) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearNamedFramebufferfv(framebuffer, buffer, drawbuffer, value);
}
GLAPI void glClearNamedFramebufferfi(GLuint framebuffer, GLenum buffer, GLint drawbuffer, GLfloat depth, GLint stencil) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glClearNamedFramebufferfi(framebuffer, buffer, drawbuffer, depth, stencil);
}
GLAPI void glBlitNamedFramebuffer(GLuint readFramebuffer, GLuint drawFramebuffer, GLint srcX0, GLint srcY0, GLint srcX1, GLint srcY1, GLint dstX0, GLint dstY0, GLint dstX1, GLint dstY1, GLbitfield mask, GLenum filter) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBlitNamedFramebuffer(readFramebuffer, drawFramebuffer, srcX0, srcY0, srcX1, srcY1, dstX0, dstY0, dstX1, dstY1, mask, filter);
}
GLAPI GLenum glCheckNamedFramebufferStatus(GLuint framebuffer, GLenum target) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glCheckNamedFramebufferStatus(framebuffer, target);
}
GLAPI void glGetNamedFramebufferParameteriv(GLuint framebuffer, GLenum pname, GLint *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedFramebufferParameteriv(framebuffer, pname, param);
}
GLAPI void glGetNamedFramebufferAttachmentParameteriv(GLuint framebuffer, GLenum attachment, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedFramebufferAttachmentParameteriv(framebuffer, attachment, pname, params);
}
GLAPI void glCreateRenderbuffers(GLsizei n, GLuint *renderbuffers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateRenderbuffers(n, renderbuffers);
}
GLAPI void glNamedRenderbufferStorage(GLuint renderbuffer, GLenum internalformat, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedRenderbufferStorage(renderbuffer, internalformat, width, height);
}
GLAPI void glNamedRenderbufferStorageMultisample(GLuint renderbuffer, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glNamedRenderbufferStorageMultisample(renderbuffer, samples, internalformat, width, height);
}
GLAPI void glGetNamedRenderbufferParameteriv(GLuint renderbuffer, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetNamedRenderbufferParameteriv(renderbuffer, pname, params);
}
GLAPI void glCreateTextures(GLenum target, GLsizei n, GLuint *textures) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateTextures(target, n, textures);
}
GLAPI void glTextureBuffer(GLuint texture, GLenum internalformat, GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureBuffer(texture, internalformat, buffer);
}
GLAPI void glTextureBufferRange(GLuint texture, GLenum internalformat, GLuint buffer, GLintptr offset, GLsizeiptr size) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureBufferRange(texture, internalformat, buffer, offset, size);
}
GLAPI void glTextureStorage1D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureStorage1D(texture, levels, internalformat, width);
}
GLAPI void glTextureStorage2D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureStorage2D(texture, levels, internalformat, width, height);
}
GLAPI void glTextureStorage3D(GLuint texture, GLsizei levels, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureStorage3D(texture, levels, internalformat, width, height, depth);
}
GLAPI void glTextureStorage2DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLboolean fixedsamplelocations) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureStorage2DMultisample(texture, samples, internalformat, width, height, fixedsamplelocations);
}
GLAPI void glTextureStorage3DMultisample(GLuint texture, GLsizei samples, GLenum internalformat, GLsizei width, GLsizei height, GLsizei depth, GLboolean fixedsamplelocations) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureStorage3DMultisample(texture, samples, internalformat, width, height, depth, fixedsamplelocations);
}
GLAPI void glTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLenum type, const void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureSubImage1D(texture, level, xoffset, width, format, type, pixels);
}
GLAPI void glTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, type, pixels);
}
GLAPI void glTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, const void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, pixels);
}
GLAPI void glCompressedTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLsizei width, GLenum format, GLsizei imageSize, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTextureSubImage1D(texture, level, xoffset, width, format, imageSize, data);
}
GLAPI void glCompressedTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTextureSubImage2D(texture, level, xoffset, yoffset, width, height, format, imageSize, data);
}
GLAPI void glCompressedTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLsizei imageSize, const void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCompressedTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, imageSize, data);
}
GLAPI void glCopyTextureSubImage1D(GLuint texture, GLint level, GLint xoffset, GLint x, GLint y, GLsizei width) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTextureSubImage1D(texture, level, xoffset, x, y, width);
}
GLAPI void glCopyTextureSubImage2D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTextureSubImage2D(texture, level, xoffset, yoffset, x, y, width, height);
}
GLAPI void glCopyTextureSubImage3D(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLint x, GLint y, GLsizei width, GLsizei height) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCopyTextureSubImage3D(texture, level, xoffset, yoffset, zoffset, x, y, width, height);
}
GLAPI void glTextureParameterf(GLuint texture, GLenum pname, GLfloat param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureParameterf(texture, pname, param);
}
GLAPI void glTextureParameterfv(GLuint texture, GLenum pname, const GLfloat *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureParameterfv(texture, pname, param);
}
GLAPI void glTextureParameteri(GLuint texture, GLenum pname, GLint param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureParameteri(texture, pname, param);
}
GLAPI void glTextureParameterIiv(GLuint texture, GLenum pname, const GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureParameterIiv(texture, pname, params);
}
GLAPI void glTextureParameterIuiv(GLuint texture, GLenum pname, const GLuint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureParameterIuiv(texture, pname, params);
}
GLAPI void glTextureParameteriv(GLuint texture, GLenum pname, const GLint *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureParameteriv(texture, pname, param);
}
GLAPI void glGenerateTextureMipmap(GLuint texture) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGenerateTextureMipmap(texture);
}
GLAPI void glBindTextureUnit(GLuint unit, GLuint texture) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glBindTextureUnit(unit, texture);
}
GLAPI void glGetTextureImage(GLuint texture, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureImage(texture, level, format, type, bufSize, pixels);
}
GLAPI void glGetCompressedTextureImage(GLuint texture, GLint level, GLsizei bufSize, void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetCompressedTextureImage(texture, level, bufSize, pixels);
}
GLAPI void glGetTextureLevelParameterfv(GLuint texture, GLint level, GLenum pname, GLfloat *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureLevelParameterfv(texture, level, pname, params);
}
GLAPI void glGetTextureLevelParameteriv(GLuint texture, GLint level, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureLevelParameteriv(texture, level, pname, params);
}
GLAPI void glGetTextureParameterfv(GLuint texture, GLenum pname, GLfloat *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureParameterfv(texture, pname, params);
}
GLAPI void glGetTextureParameterIiv(GLuint texture, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureParameterIiv(texture, pname, params);
}
GLAPI void glGetTextureParameterIuiv(GLuint texture, GLenum pname, GLuint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureParameterIuiv(texture, pname, params);
}
GLAPI void glGetTextureParameteriv(GLuint texture, GLenum pname, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureParameteriv(texture, pname, params);
}
GLAPI void glCreateVertexArrays(GLsizei n, GLuint *arrays) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateVertexArrays(n, arrays);
}
GLAPI void glDisableVertexArrayAttrib(GLuint vaobj, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glDisableVertexArrayAttrib(vaobj, index);
}
GLAPI void glEnableVertexArrayAttrib(GLuint vaobj, GLuint index) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glEnableVertexArrayAttrib(vaobj, index);
}
GLAPI void glVertexArrayElementBuffer(GLuint vaobj, GLuint buffer) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayElementBuffer(vaobj, buffer);
}
GLAPI void glVertexArrayVertexBuffer(GLuint vaobj, GLuint bindingindex, GLuint buffer, GLintptr offset, GLsizei stride) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayVertexBuffer(vaobj, bindingindex, buffer, offset, stride);
}
GLAPI void glVertexArrayVertexBuffers(GLuint vaobj, GLuint first, GLsizei count, const GLuint *buffers, const GLintptr *offsets, const GLsizei *strides) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayVertexBuffers(vaobj, first, count, buffers, offsets, strides);
}
GLAPI void glVertexArrayAttribBinding(GLuint vaobj, GLuint attribindex, GLuint bindingindex) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayAttribBinding(vaobj, attribindex, bindingindex);
}
GLAPI void glVertexArrayAttribFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLboolean normalized, GLuint relativeoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayAttribFormat(vaobj, attribindex, size, type, normalized, relativeoffset);
}
GLAPI void glVertexArrayAttribIFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayAttribIFormat(vaobj, attribindex, size, type, relativeoffset);
}
GLAPI void glVertexArrayAttribLFormat(GLuint vaobj, GLuint attribindex, GLint size, GLenum type, GLuint relativeoffset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayAttribLFormat(vaobj, attribindex, size, type, relativeoffset);
}
GLAPI void glVertexArrayBindingDivisor(GLuint vaobj, GLuint bindingindex, GLuint divisor) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glVertexArrayBindingDivisor(vaobj, bindingindex, divisor);
}
GLAPI void glGetVertexArrayiv(GLuint vaobj, GLenum pname, GLint *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexArrayiv(vaobj, pname, param);
}
GLAPI void glGetVertexArrayIndexediv(GLuint vaobj, GLuint index, GLenum pname, GLint *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexArrayIndexediv(vaobj, index, pname, param);
}
GLAPI void glGetVertexArrayIndexed64iv(GLuint vaobj, GLuint index, GLenum pname, GLint64 *param) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetVertexArrayIndexed64iv(vaobj, index, pname, param);
}
GLAPI void glCreateSamplers(GLsizei n, GLuint *samplers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateSamplers(n, samplers);
}
GLAPI void glCreateProgramPipelines(GLsizei n, GLuint *pipelines) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateProgramPipelines(n, pipelines);
}
GLAPI void glCreateQueries(GLenum target, GLsizei n, GLuint *ids) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glCreateQueries(target, n, ids);
}
GLAPI void glGetQueryBufferObjecti64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryBufferObjecti64v(id, buffer, pname, offset);
}
GLAPI void glGetQueryBufferObjectiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryBufferObjectiv(id, buffer, pname, offset);
}
GLAPI void glGetQueryBufferObjectui64v(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryBufferObjectui64v(id, buffer, pname, offset);
}
GLAPI void glGetQueryBufferObjectuiv(GLuint id, GLuint buffer, GLenum pname, GLintptr offset) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetQueryBufferObjectuiv(id, buffer, pname, offset);
}
GLAPI void glMemoryBarrierByRegion(GLbitfield barriers) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMemoryBarrierByRegion(barriers);
}
GLAPI void glGetTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLenum format, GLenum type, GLsizei bufSize, void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, format, type, bufSize, pixels);
}
GLAPI void glGetCompressedTextureSubImage(GLuint texture, GLint level, GLint xoffset, GLint yoffset, GLint zoffset, GLsizei width, GLsizei height, GLsizei depth, GLsizei bufSize, void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetCompressedTextureSubImage(texture, level, xoffset, yoffset, zoffset, width, height, depth, bufSize, pixels);
}
GLAPI GLenum glGetGraphicsResetStatus(void) {
	assert(glad_glGetString && "GLAD not initialized!");
	return glad_glGetGraphicsResetStatus();
}
GLAPI void glGetnCompressedTexImage(GLenum target, GLint lod, GLsizei bufSize, void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnCompressedTexImage(target, lod, bufSize, pixels);
}
GLAPI void glGetnTexImage(GLenum target, GLint level, GLenum format, GLenum type, GLsizei bufSize, void *pixels) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnTexImage(target, level, format, type, bufSize, pixels);
}
GLAPI void glGetnUniformdv(GLuint program, GLint location, GLsizei bufSize, GLdouble *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnUniformdv(program, location, bufSize, params);
}
GLAPI void glGetnUniformfv(GLuint program, GLint location, GLsizei bufSize, GLfloat *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnUniformfv(program, location, bufSize, params);
}
GLAPI void glGetnUniformiv(GLuint program, GLint location, GLsizei bufSize, GLint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnUniformiv(program, location, bufSize, params);
}
GLAPI void glGetnUniformuiv(GLuint program, GLint location, GLsizei bufSize, GLuint *params) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnUniformuiv(program, location, bufSize, params);
}
GLAPI void glReadnPixels(GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLsizei bufSize, void *data) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glReadnPixels(x, y, width, height, format, type, bufSize, data);
}
GLAPI void glGetnMapdv(GLenum target, GLenum query, GLsizei bufSize, GLdouble *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnMapdv(target, query, bufSize, v);
}
GLAPI void glGetnMapfv(GLenum target, GLenum query, GLsizei bufSize, GLfloat *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnMapfv(target, query, bufSize, v);
}
GLAPI void glGetnMapiv(GLenum target, GLenum query, GLsizei bufSize, GLint *v) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnMapiv(target, query, bufSize, v);
}
GLAPI void glGetnPixelMapfv(GLenum map, GLsizei bufSize, GLfloat *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnPixelMapfv(map, bufSize, values);
}
GLAPI void glGetnPixelMapuiv(GLenum map, GLsizei bufSize, GLuint *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnPixelMapuiv(map, bufSize, values);
}
GLAPI void glGetnPixelMapusv(GLenum map, GLsizei bufSize, GLushort *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnPixelMapusv(map, bufSize, values);
}
GLAPI void glGetnPolygonStipple(GLsizei bufSize, GLubyte *pattern) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnPolygonStipple(bufSize, pattern);
}
GLAPI void glGetnColorTable(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *table) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnColorTable(target, format, type, bufSize, table);
}
GLAPI void glGetnConvolutionFilter(GLenum target, GLenum format, GLenum type, GLsizei bufSize, void *image) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnConvolutionFilter(target, format, type, bufSize, image);
}
GLAPI void glGetnSeparableFilter(GLenum target, GLenum format, GLenum type, GLsizei rowBufSize, void *row, GLsizei columnBufSize, void *column, void *span) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnSeparableFilter(target, format, type, rowBufSize, row, columnBufSize, column, span);
}
GLAPI void glGetnHistogram(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnHistogram(target, reset, format, type, bufSize, values);
}
GLAPI void glGetnMinmax(GLenum target, GLboolean reset, GLenum format, GLenum type, GLsizei bufSize, void *values) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glGetnMinmax(target, reset, format, type, bufSize, values);
}
GLAPI void glTextureBarrier(void) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glTextureBarrier();
}
#endif

// 4.6
#ifndef __GL_FUNCTION_MACROS__
GLAPI void glSpecializeShader(GLuint shader, const GLchar *pEntryPoint, GLuint numSpecializationConstants, const GLuint *pConstantIndex, const GLuint *pConstantValue) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glSpecializeShader(shader, pEntryPoint, numSpecializationConstants, pConstantIndex, pConstantValue);
}
GLAPI void glMultiDrawArraysIndirectCount(GLenum mode, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawArraysIndirectCount(mode, indirect, drawcount, maxdrawcount, stride);
}
GLAPI void glMultiDrawElementsIndirectCount(GLenum mode, GLenum type, const void *indirect, GLintptr drawcount, GLsizei maxdrawcount, GLsizei stride) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glMultiDrawElementsIndirectCount(mode, type, indirect, drawcount, maxdrawcount, stride);
}
GLAPI void glPolygonOffsetClamp(GLfloat factor, GLfloat units, GLfloat clamp) {
	assert(glad_glGetString && "GLAD not initialized!");
	glad_glPolygonOffsetClamp(factor, units, clamp);
}
#endif